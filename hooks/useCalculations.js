/**
 * useCalculations Hook
 * Computes calculation arrays with formula evaluation
 */
import { useMemo } from 'react'
import { evaluateSimpleFormula } from '@/utils/simpleFormulaEvaluator'

/**
 * Hook for computing calculation arrays
 */
export function useCalculations({
    calculations,
    calculationsGroups,
    timeline,
    inputType1Arrays,
    inputGlassArrays,
    autoGeneratedFlags
}) {
    // Extract references from all calculation formulas
    const calculationReferences = useMemo(() => {
        const refs = new Set()
        calculations.forEach(calc => {
            if (calc.formula) {
                const matches = calc.formula.match(/\{([^}]+)\}/g)
                if (matches) {
                    matches.forEach(match => {
                        const refId = match.slice(1, -1).trim()
                        refs.add(refId)
                    })
                }
            }
        })
        return Array.from(refs)
    }, [calculations])

    // Convert calculations to time series arrays
    // Use iterative approach to handle cross-references between calculations
    const calculationsArrays = useMemo(() => {
        const arrays = {}

        // First pass: initialize all arrays
        calculations.forEach(calculation => {
            arrays[`calc_${calculation.id}`] = new Array(timeline.periods).fill(0)
        })

        // Second pass: evaluate formulas (may need multiple iterations for dependencies)
        let maxIterations = 10
        let iteration = 0
        let hasChanges = true

        while (hasChanges && iteration < maxIterations) {
            hasChanges = false
            iteration++

            calculations.forEach(calculation => {
                const arr = arrays[`calc_${calculation.id}`] || new Array(timeline.periods).fill(0)
                // Get start and end year/month from group
                const group = calculationsGroups.find(g => g.id === calculation.groupId)
                if (!group) return

                const startTotal = group.startYear * 12 + group.startMonth
                const endTotal = group.endYear * 12 + group.endMonth
                const timePeriod = calculation.timePeriod || 'Y' // Y, Q, M

                // Calculate periods per time period
                let periodsPerTimePeriod = 1
                if (timePeriod === 'Y') {
                    periodsPerTimePeriod = 12 // 12 months per year
                } else if (timePeriod === 'Q') {
                    periodsPerTimePeriod = 3 // 3 months per quarter
                } else if (timePeriod === 'M') {
                    periodsPerTimePeriod = 1 // 1 month per month
                }

                // Build context for formula evaluation
                const buildContext = (periodIndex) => {
                    const context = {}

                    // Add constant
                    context.constant = calculation.constant || 1

                    // Add input type 1 arrays
                    Object.keys(inputType1Arrays).forEach(key => {
                        const inputArr = inputType1Arrays[key]
                        if (inputArr && inputArr[periodIndex] !== undefined) {
                            context[key] = inputArr
                        }
                    })

                    // Add InputGlass arrays
                    if (inputGlassArrays) {
                        Object.keys(inputGlassArrays).forEach(key => {
                            const inputArr = inputGlassArrays[key]
                            if (inputArr && inputArr[periodIndex] !== undefined) {
                                context[key] = inputArr
                            }
                        })
                    }

                    // Add flags
                    Object.values(autoGeneratedFlags).forEach(flag => {
                        if (flag.array && flag.array[periodIndex] !== undefined) {
                            context[flag.id] = flag.array
                        }
                    })

                    // Add other calculations (for cross-references) - use calc_ prefix
                    calculations.forEach(otherCalc => {
                        const otherKey = `calc_${otherCalc.id}`
                        if (arrays[otherKey] && arrays[otherKey][periodIndex] !== undefined) {
                            context[otherKey] = arrays[otherKey]
                        }
                    })

                    return context
                }

                for (let i = 0; i < timeline.periods; i++) {
                    const periodTotal = timeline.year[i] * 12 + timeline.month[i]

                    // Check if period is within start/end range
                    if (periodTotal < startTotal || periodTotal > endTotal) {
                        const oldValue = arr[i]
                        arr[i] = 0
                        if (oldValue !== 0) {
                            hasChanges = true
                        }
                        continue
                    }

                    // Evaluate formula for this period
                    let value = 0
                    if (calculation.formula) {
                        const context = buildContext(i)
                        const evaluated = evaluateSimpleFormula(calculation.formula, context, i)
                        if (!isNaN(evaluated) && isFinite(evaluated)) {
                            value = evaluated
                        }
                    } else {
                        // No formula, use constant
                        value = calculation.constant || 0
                    }

                    // Apply time period distribution
                    value = value / periodsPerTimePeriod

                    // Apply flag multiplier if flag reference exists
                    if (calculation.flagReferenceId) {
                        const flag = autoGeneratedFlags[calculation.flagReferenceId]
                        if (flag && flag.array && flag.array[i] !== undefined) {
                            value = value * flag.array[i]
                        }
                    }

                    const oldValue = arr[i]
                    arr[i] = value
                    if (Math.abs(oldValue - value) > 0.0001) {
                        hasChanges = true
                    }
                }

                arrays[`calc_${calculation.id}`] = arr
            })
        }

        return arrays
    }, [calculations, calculationsGroups, timeline, inputType1Arrays, inputGlassArrays, autoGeneratedFlags])

    return {
        calculationReferences,
        calculationsArrays
    }
}
