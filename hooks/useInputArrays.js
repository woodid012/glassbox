/**
 * useInputArrays Hook
 * Computes time series arrays for all input types
 */
import { useMemo } from 'react'
import { evaluateSimpleFormula } from '@/utils/simpleFormulaEvaluator'
import { detectFlowOrStock, materializeInput } from '@/utils/valueProvider'

// Re-export detectFlowOrStock for backwards compatibility
export { detectFlowOrStock }

/**
 * Hook for computing input arrays from input definitions
 */
export function useInputArrays({
    timeline,
    config,
    inputType1,
    inputType1Groups,
    inputGlass,
    inputGlassGroups,
    indices,
    keyPeriods,
    inputs
}) {
    // Convert input type 1 to time series arrays
    const inputType1Arrays = useMemo(() => {
        const arrays = {}
        inputType1.forEach(simpleInput => {
            const arr = new Array(timeline.periods).fill(0)
            // Get start year/month and periods from group
            const group = inputType1Groups.find(g => g.id === simpleInput.groupId)
            if (!group) return

            // Handle constant groups - apply single value to all periods
            if (group.linkedKeyPeriodId === 'constant') {
                const constantValue = simpleInput.values?.[0] || 0
                // If there's a formula, calculate it
                if (simpleInput.formulas?.[0]) {
                    const calculated = evaluateSimpleFormula(simpleInput.formulas[0])
                    if (!isNaN(calculated) && isFinite(calculated)) {
                        arr.fill(calculated)
                    } else {
                        arr.fill(constantValue)
                    }
                } else {
                    arr.fill(constantValue)
                }
            } else {
                const startYear = group.startYear
                const startMonth = group.startMonth
                const periods = parseInt(group.periods) || 1

                // Find start index in timeline using year/month
                let startIndex = -1
                for (let i = 0; i < timeline.periods; i++) {
                    if (timeline.year[i] === startYear && timeline.month[i] === startMonth) {
                        startIndex = i
                        break
                    }
                }

                // Fill values for the specified number of periods
                if (startIndex >= 0) {
                    for (let i = 0; i < periods && (startIndex + i) < timeline.periods; i++) {
                        arr[startIndex + i] = simpleInput.values?.[i] || 0
                    }
                }
            }

            arrays[`inputtype1_${simpleInput.id}`] = arr
        })
        return arrays
    }, [inputType1, inputType1Groups, timeline])

    // Auto-generate indexation arrays from indices
    const autoGeneratedIndexations = useMemo(() => {
        const indexations = {}

        indices.forEach(index => {
            const arr = new Array(timeline.periods).fill(0)

            // Special case: "None" index always returns 1's (no indexation)
            if (index.name === 'None' || index.id === 1) {
                arr.fill(1)
            } else {
                const indexStartYear = index.indexationStartYear
                const indexStartMonth = index.indexationStartMonth
                const indexStartTotal = indexStartYear * 12 + indexStartMonth
                const rate = index.indexationRate / 100

                for (let i = 0; i < timeline.periods; i++) {
                    const periodYear = timeline.year[i]
                    const periodMonth = timeline.month[i]
                    const periodTotal = periodYear * 12 + periodMonth

                    // Only calculate indexation for periods on or after indexation start
                    if (periodTotal >= indexStartTotal) {
                        if (index.indexationPeriod === 'monthly') {
                            // Monthly compounding: count months from indexation start
                            const monthsElapsed = periodTotal - indexStartTotal
                            arr[i] = Math.pow(1 + rate / 12, monthsElapsed)
                        } else {
                            // Annual compounding: count calendar years from indexation start
                            const yearsElapsed = periodYear - indexStartYear
                            arr[i] = Math.pow(1 + rate, yearsElapsed)
                        }
                    } else {
                        arr[i] = 1 // Before indexation starts, factor is 1
                    }
                }
            }

            indexations[`index_${index.id}`] = {
                id: `index_${index.id}`,
                name: index.name,
                array: arr
            }
        })

        return indexations
    }, [indices, timeline])

    // Convert InputGlass to time series arrays using valueProvider
    const inputGlassArrays = useMemo(() => {
        const arrays = {}
        if (!inputGlass || !Array.isArray(inputGlass)) return arrays

        inputGlass.forEach(input => {
            const group = inputGlassGroups?.find(g => g.id === input.groupId)

            if (!group) {
                // Return empty array if no group found
                arrays[`inputtype3_${input.id}`] = new Array(timeline.periods).fill(0)
                return
            }

            // Use valueProvider to materialize the input array
            const context = { timeline, group }
            arrays[`inputtype3_${input.id}`] = materializeInput(input, context)
        })
        return arrays
    }, [inputGlass, inputGlassGroups, timeline])

    // Auto-generate flag arrays from inputs
    const autoGeneratedFlags = useMemo(() => {
        const flags = {}

        // Flags from Input Type 1: 1 when input has values, 0 otherwise
        inputType1.forEach(simpleInput => {
            const arr = new Array(timeline.periods).fill(0)
            // Get start year/month and periods from group
            const group = inputType1Groups.find(g => g.id === simpleInput.groupId)
            if (!group) return

            // Handle constant groups - flag is always 1 for all periods
            if (group.linkedKeyPeriodId === 'constant') {
                // Check if input has a value (either direct value or formula)
                const hasValue = (simpleInput.values?.[0] !== undefined && simpleInput.values[0] !== null && simpleInput.values[0] !== '') ||
                    (simpleInput.formulas?.[0] !== undefined && simpleInput.formulas[0] !== null && simpleInput.formulas[0] !== '')
                if (hasValue) {
                    arr.fill(1)
                }
            } else {
                const startYear = group.startYear
                const startMonth = group.startMonth
                const periods = parseInt(group.periods) || 1

                // Find start index in timeline using year/month
                let startIndex = -1
                for (let i = 0; i < timeline.periods; i++) {
                    if (timeline.year[i] === startYear && timeline.month[i] === startMonth) {
                        startIndex = i
                        break
                    }
                }

                // Set flag to 1 for periods that have values
                if (startIndex >= 0) {
                    for (let i = 0; i < periods && (startIndex + i) < timeline.periods; i++) {
                        if (simpleInput.values?.[i] !== undefined && simpleInput.values[i] !== null && simpleInput.values[i] !== '') {
                            arr[startIndex + i] = 1
                        }
                    }
                }
            }

            flags[`flag_inputtype1_${simpleInput.id}`] = {
                id: `flag_inputtype1_${simpleInput.id}`,
                name: `${simpleInput.name} Flag`,
                array: arr
            }
        })

        // Flags from Key Periods: 1 when within period's start/end, 0 otherwise
        keyPeriods.forEach(keyPeriod => {
            const arr = new Array(timeline.periods).fill(0)

            const startTotal = keyPeriod.startYear * 12 + keyPeriod.startMonth
            const endTotal = keyPeriod.endYear * 12 + keyPeriod.endMonth

            for (let i = 0; i < timeline.periods; i++) {
                const periodTotal = timeline.year[i] * 12 + timeline.month[i]
                if (periodTotal >= startTotal && periodTotal <= endTotal) {
                    arr[i] = 1
                }
            }

            flags[`flag_keyperiod_${keyPeriod.id}`] = {
                id: `flag_keyperiod_${keyPeriod.id}`,
                name: `${keyPeriod.name} Flag`,
                array: arr
            }
        })

        return flags
    }, [inputType1, inputType1Groups, timeline, keyPeriods])

    // Calculate full input arrays (resolving defaults and overrides)
    const inputArrays = useMemo(() => {
        const arrays = {}
        const allInputs = inputs

        // First pass: Calculate all arrays (flags and indexation first, then values)
        allInputs.forEach(input => {
            const arr = new Array(timeline.periods).fill(0)

            // Get input's period range
            const inputStartYear = input.startYear ?? config.startYear
            const inputStartMonth = input.startMonth ?? config.startMonth
            const inputEndYear = input.endYear ?? config.endYear
            const inputEndMonth = input.endMonth ?? config.endMonth
            const inputStartTotal = inputStartYear * 12 + inputStartMonth
            const inputEndTotal = inputEndYear * 12 + inputEndMonth

            // Fill based on category, frequency and defaults
            for (let i = 0; i < timeline.periods; i++) {
                const periodYear = timeline.year[i]
                const periodMonth = timeline.month[i]
                const periodTotal = periodYear * 12 + periodMonth

                // For flag/indexation: check period range
                let isWithinDateRange = true
                if (input.category === 'flag' || input.category === 'indexation') {
                    isWithinDateRange = periodTotal >= inputStartTotal && periodTotal <= inputEndTotal
                    if (!isWithinDateRange && input.category === 'indexation') {
                        arr[i] = 0
                        continue
                    }
                }

                // Check if there's an override value
                if (input.values[i] !== undefined) {
                    // For flags, ensure value is 0 or 1
                    if (input.category === 'flag') {
                        arr[i] = input.values[i] === 1 || input.values[i] === '1' ? 1 : 0
                    } else {
                        arr[i] = input.values[i]
                    }
                } else {
                    // Calculate value based on category
                    if (input.category === 'indexation') {
                        const indexationPeriod = input.indexationPeriod || 'annual'
                        const rate = input.indexationRate || 0

                        let indexationFactor
                        if (indexationPeriod === 'monthly') {
                            const monthsElapsed = periodTotal - inputStartTotal
                            indexationFactor = Math.pow(1 + rate / 12, monthsElapsed)
                        } else {
                            const yearsElapsed = periodYear - inputStartYear
                            indexationFactor = Math.pow(1 + rate, yearsElapsed)
                        }
                        arr[i] = indexationFactor
                    } else if (input.category === 'flag') {
                        if (input.id === -1 || input.name === 'Timeline') {
                            arr[i] = 1
                        } else {
                            arr[i] = isWithinDateRange ? 1 : 0
                        }
                    } else {
                        arr[i] = input.defaultValue
                    }
                }
            }

            arrays[input.id] = arr
        })

        // Second pass: Apply linked flags to value inputs
        allInputs.forEach(input => {
            if (input.category === 'value' && input.linkedFlagId) {
                const flagArray = arrays[input.linkedFlagId]
                if (flagArray) {
                    const arr = arrays[input.id]
                    for (let i = 0; i < timeline.periods; i++) {
                        if (flagArray[i] !== 1) {
                            arr[i] = 0
                        }
                    }
                }
            }
        })

        // Third pass: Apply indexation to value inputs that reference indexation inputs
        allInputs.forEach(input => {
            if (input.category === 'value' && input.indexationInputId && arrays[input.indexationInputId] && arrays[input.id]) {
                const indexationArray = arrays[input.indexationInputId]
                const arr = arrays[input.id]
                for (let i = 0; i < timeline.periods; i++) {
                    arr[i] = arr[i] * indexationArray[i]
                }
            }
        })

        // Fourth pass: Apply formulas
        allInputs.forEach(input => {
            if (input.formula && arrays[input.id]) {
                const arr = arrays[input.id]
                const formula = input.formula.toLowerCase()

                for (let i = 0; i < timeline.periods; i++) {
                    let result = arr[i]

                    if (formula.includes('indexation') && input.indexationRate > 0) {
                        const indexationInput = allInputs.find(inp =>
                            inp.category === 'indexation' && inp.indexationRate === input.indexationRate
                        )
                        if (indexationInput && arrays[indexationInput.id]) {
                            result *= arrays[indexationInput.id][i]
                        }
                    }

                    if (formula.includes('flag') && input.linkedFlagId) {
                        const flagArray = arrays[input.linkedFlagId]
                        if (flagArray) {
                            result *= flagArray[i]
                        }
                    }

                    arr[i] = result
                }
            }
        })

        return arrays
    }, [inputs, timeline, config.startDate, config.endDate])

    return {
        inputType1Arrays,
        inputGlassArrays,
        autoGeneratedIndexations,
        autoGeneratedFlags,
        inputArrays
    }
}
