/**
 * useInputArrays Hook
 * Computes time series arrays for all input types
 */
import { useMemo } from 'react'
import { evaluateSimpleFormula } from '@/utils/simpleFormulaEvaluator'
import { getValuesArray, generatePeriods } from '@/components/inputs/utils/inputHelpers'

// Time Constants - explicit for Glass Box transparency
const MONTHS_IN_YEAR = 12

/**
 * Constant Array Factory - creates and caches filled arrays
 * For constant values, we can share the same array instance (read-only)
 * This reduces memory allocation from O(n * periods) to O(unique_values * periods)
 */
function createConstantArrayFactory(periods) {
    const cache = new Map()

    // Pre-create common arrays
    const ZEROS = new Array(periods).fill(0)
    const ONES = new Array(periods).fill(1)
    cache.set(0, ZEROS)
    cache.set(1, ONES)

    return {
        // Get a filled array (cached if same value requested before)
        getFilledArray: (value) => {
            if (value === 0) return ZEROS
            if (value === 1) return ONES

            if (cache.has(value)) return cache.get(value)

            const arr = new Array(periods).fill(value)
            cache.set(value, arr)
            return arr
        },
        // Get a fresh array (for arrays that will be modified)
        getFreshArray: () => new Array(periods).fill(0),
        // Get zeros (always safe to share, most common)
        getZeros: () => ZEROS,
        // Get ones (always safe to share)
        getOnes: () => ONES,
    }
}

/**
 * Hook for computing input arrays from input definitions
 */
export function useInputArrays({
    timeline,
    config,
    inputType1,
    inputType1Groups,
    inputGlass,
    inputGlassGroups,
    indices,
    keyPeriods,
    inputs
}) {
    // Constant array factory - caches filled arrays to reduce memory allocation
    const arrayFactory = useMemo(() =>
        createConstantArrayFactory(timeline.periods),
    [timeline.periods])

    // Pre-compute timeline lookup Map for O(1) lookups instead of O(n) loops
    // This dramatically speeds up timeline index lookups from O(n) to O(1)
    const timelineLookup = useMemo(() => {
        const map = new Map()
        for (let i = 0; i < timeline.periods; i++) {
            const key = `${timeline.year[i]}-${timeline.month[i]}`
            map.set(key, i)
        }
        return map
    }, [timeline.periods, timeline.year, timeline.month])

    // Pre-index inputType1 groups by ID for O(1) lookups
    const inputType1GroupsById = useMemo(() => {
        const map = new Map()
        ;(inputType1Groups || []).forEach(g => map.set(g.id, g))
        return map
    }, [inputType1Groups])

    // Convert input type 1 to time series arrays
    const inputType1Arrays = useMemo(() => {
        const arrays = {}
        inputType1.forEach(simpleInput => {
            // O(1) lookup using pre-indexed Map
            const group = inputType1GroupsById.get(simpleInput.groupId)
            if (!group) return

            // Handle constant groups - use cached arrays (read-only, shared)
            if (group.linkedKeyPeriodId === 'constant') {
                let constantValue = simpleInput.values?.[0] || 0
                // If there's a formula, calculate it
                if (simpleInput.formulas?.[0]) {
                    const calculated = evaluateSimpleFormula(simpleInput.formulas[0])
                    if (!isNaN(calculated) && isFinite(calculated)) {
                        constantValue = calculated
                    }
                }
                // Use cached array for constant value
                arrays[`inputtype1_${simpleInput.id}`] = arrayFactory.getFilledArray(constantValue)
                return
            }

            // Non-constant: need fresh array that will be modified
            const arr = arrayFactory.getFreshArray()
            const startYear = group.startYear
                const startMonth = group.startMonth
                const periods = parseInt(group.periods) || 1

                // O(1) lookup using pre-computed Map instead of O(n) loop
                const startIndex = timelineLookup.get(`${startYear}-${startMonth}`) ?? -1

                // Fill values for the specified number of periods
                if (startIndex >= 0) {
                    for (let i = 0; i < periods && (startIndex + i) < timeline.periods; i++) {
                        arr[startIndex + i] = simpleInput.values?.[i] || 0
                    }
                }

            arrays[`inputtype1_${simpleInput.id}`] = arr
        })
        return arrays
    }, [inputType1, inputType1GroupsById, timeline, timelineLookup, arrayFactory])

    // Auto-generate indexation arrays from indices
    const autoGeneratedIndexations = useMemo(() => {
        const indexations = {}

        indices.forEach(index => {
            // Special case: "None" index always returns 1's (no indexation)
            if (index.name === 'None' || index.id === 1) {
                indexations[`index_${index.id}`] = {
                    id: `index_${index.id}`,
                    name: index.name,
                    array: arrayFactory.getOnes() // Shared ones array
                }
                return
            }

            // Non-trivial indexation: needs fresh array
            const arr = arrayFactory.getFreshArray()
            const indexStartYear = index.indexationStartYear
            const indexStartMonth = index.indexationStartMonth
            const indexStartTotal = indexStartYear * 12 + indexStartMonth
            const rate = index.indexationRate / 100

            for (let i = 0; i < timeline.periods; i++) {
                const periodTotal = timeline.year[i] * 12 + timeline.month[i]
                const monthsFromBase = periodTotal - indexStartTotal

                if (monthsFromBase >= 0) {
                    if (index.indexationPeriod === 'monthly') {
                        // Monthly compounding: true compound monthly rate
                        const monthlyRate = Math.pow(1 + rate, 1/12) - 1
                        arr[i] = Math.pow(1 + monthlyRate, monthsFromBase)
                    } else {
                        // Annual stepwise: flat for 12 months, then step up
                        const wholeYears = Math.floor(monthsFromBase / 12)
                        arr[i] = Math.pow(1 + rate, wholeYears)
                    }
                } else {
                    arr[i] = 1 // Before indexation starts, factor is 1
                }
            }

            indexations[`index_${index.id}`] = {
                id: `index_${index.id}`,
                name: index.name,
                array: arr
            }
        })

        return indexations
    }, [indices, timeline, arrayFactory])

    // Pre-index groups by ID for O(1) lookups instead of O(n) find() calls
    const groupsById = useMemo(() => {
        const map = new Map()
        ;(inputGlassGroups || []).forEach(g => map.set(g.id, g))
        return map
    }, [inputGlassGroups])

    // Convert InputGlass to time series arrays using getValuesArray (same as Inputs preview)
    const inputGlassArrays = useMemo(() => {
        const arrays = {}
        if (!inputGlass || !Array.isArray(inputGlass)) return arrays

        const prefillEnabled = config?.prefillLookups !== false

        inputGlass.forEach(input => {
            // O(1) lookup using pre-indexed Map
            const group = groupsById.get(input.groupId)

            if (!group) {
                // Return shared zeros array if no group found
                arrays[`inputtype3_${input.id}`] = arrayFactory.getZeros()
                return
            }

            // Generate group's periods at MONTHLY frequency for model timeline mapping
            // Always use 'M' regardless of group.frequency to ensure proper month-by-month mapping
            const groupPeriods = generatePeriods(group, config, keyPeriods, 'M')

            // Get values at monthly frequency using the same logic as Inputs preview
            const groupValues = getValuesArray(input, groupPeriods, 'M', group, config)

            // For constant mode, use cached filled array (shared, read-only)
            const isConstantMode = group.entryMode === 'constant'
            if (isConstantMode && groupValues.length > 0) {
                // getValuesArray already computed the correct per-period value via generateConstantValues
                const constantValue = groupValues[0] || 0
                arrays[`inputtype3_${input.id}`] = arrayFactory.getFilledArray(constantValue)
                return
            }

            // Non-constant modes: need fresh array that will be modified
            let arr = arrayFactory.getFreshArray()
            // Map group values to model timeline using O(1) Map lookup
            groupPeriods.forEach((period, periodIdx) => {
                const t = timelineLookup.get(`${period.year}-${period.month}`)
                if (t !== undefined) {
                    arr[t] = groupValues[periodIdx] || 0
                }
            })

            // Apply forward-fill ONLY for lookup modes when prefill is enabled
            const isLookupMode = group.entryMode === 'lookup' || group.entryMode === 'lookup2'
            if (isLookupMode && prefillEnabled) {
                let lastNonZero = 0
                arr = arr.map(val => {
                    if (val !== 0) {
                        lastNonZero = val
                        return val
                    }
                    return lastNonZero
                })
            }

            arrays[`inputtype3_${input.id}`] = arr
        })
        return arrays
    }, [inputGlass, groupsById, timeline, config, keyPeriods, timelineLookup, arrayFactory])

    // Auto-generate flag arrays from inputs
    const autoGeneratedFlags = useMemo(() => {
        const flags = {}

        // Flags from Input Type 1: 1 when input has values, 0 otherwise
        inputType1.forEach(simpleInput => {
            const arr = new Array(timeline.periods).fill(0)
            // O(1) lookup using pre-indexed Map
            const group = inputType1GroupsById.get(simpleInput.groupId)
            if (!group) return

            // Handle constant groups - flag is always 1 for all periods
            if (group.linkedKeyPeriodId === 'constant') {
                // Check if input has a value (either direct value or formula)
                const hasValue = (simpleInput.values?.[0] !== undefined && simpleInput.values[0] !== null && simpleInput.values[0] !== '') ||
                    (simpleInput.formulas?.[0] !== undefined && simpleInput.formulas[0] !== null && simpleInput.formulas[0] !== '')
                if (hasValue) {
                    arr.fill(1)
                }
            } else {
                const startYear = group.startYear
                const startMonth = group.startMonth
                const periods = parseInt(group.periods) || 1

                // O(1) lookup using pre-computed Map instead of O(n) loop
                const startIndex = timelineLookup.get(`${startYear}-${startMonth}`) ?? -1

                // Set flag to 1 for periods that have values
                if (startIndex >= 0) {
                    for (let i = 0; i < periods && (startIndex + i) < timeline.periods; i++) {
                        if (simpleInput.values?.[i] !== undefined && simpleInput.values[i] !== null && simpleInput.values[i] !== '') {
                            arr[startIndex + i] = 1
                        }
                    }
                }
            }

            flags[`flag_inputtype1_${simpleInput.id}`] = {
                id: `flag_inputtype1_${simpleInput.id}`,
                name: `${simpleInput.name} Flag`,
                array: arr
            }
        })

        // Flags from Key Periods: 1 when within period's start/end, 0 otherwise
        // Also generates .Start (first period only) and .End (last period only) flags
        keyPeriods.forEach(keyPeriod => {
            const arr = new Array(timeline.periods).fill(0)
            const startArr = new Array(timeline.periods).fill(0)
            const endArr = new Array(timeline.periods).fill(0)

            const startTotal = keyPeriod.startYear * 12 + keyPeriod.startMonth
            const endTotal = keyPeriod.endYear * 12 + keyPeriod.endMonth

            let firstPeriodIdx = -1
            let lastPeriodIdx = -1

            for (let i = 0; i < timeline.periods; i++) {
                const periodTotal = timeline.year[i] * 12 + timeline.month[i]
                if (periodTotal >= startTotal && periodTotal <= endTotal) {
                    arr[i] = 1
                    if (firstPeriodIdx === -1) firstPeriodIdx = i
                    lastPeriodIdx = i
                }
            }

            // Set start/end flags at boundary periods
            if (firstPeriodIdx >= 0) startArr[firstPeriodIdx] = 1
            if (lastPeriodIdx >= 0) endArr[lastPeriodIdx] = 1

            // Count total active months, derive quarters and years
            const monthCount = arr.reduce((sum, v) => sum + v, 0)
            const monthCountArray = new Array(timeline.periods).fill(monthCount)
            const quarterCountArray = new Array(timeline.periods).fill(monthCount / 3)
            const yearCountArray = new Array(timeline.periods).fill(monthCount / 12)

            flags[`flag_keyperiod_${keyPeriod.id}`] = {
                id: `flag_keyperiod_${keyPeriod.id}`,
                name: `${keyPeriod.name}`,
                array: arr,
                startArray: startArr,
                endArray: endArr,
                monthCountArray,
                quarterCountArray,
                yearCountArray
            }
        })

        return flags
    }, [inputType1, inputType1GroupsById, timeline, keyPeriods, timelineLookup])

    // Calculate full input arrays (resolving defaults and overrides)
    const inputArrays = useMemo(() => {
        const arrays = {}
        const allInputs = inputs

        // First pass: Calculate all arrays (flags and indexation first, then values)
        allInputs.forEach(input => {
            const arr = new Array(timeline.periods).fill(0)

            // Get input's period range
            const inputStartYear = input.startYear ?? config.startYear
            const inputStartMonth = input.startMonth ?? config.startMonth
            const inputEndYear = input.endYear ?? config.endYear
            const inputEndMonth = input.endMonth ?? config.endMonth
            const inputStartTotal = inputStartYear * 12 + inputStartMonth
            const inputEndTotal = inputEndYear * 12 + inputEndMonth

            // Fill based on category, frequency and defaults
            for (let i = 0; i < timeline.periods; i++) {
                const periodYear = timeline.year[i]
                const periodMonth = timeline.month[i]
                const periodTotal = periodYear * 12 + periodMonth

                // For flag/indexation: check period range
                let isWithinDateRange = true
                if (input.category === 'flag' || input.category === 'indexation') {
                    isWithinDateRange = periodTotal >= inputStartTotal && periodTotal <= inputEndTotal
                    if (!isWithinDateRange && input.category === 'indexation') {
                        arr[i] = 0
                        continue
                    }
                }

                // Check if there's an override value
                if (input.values[i] !== undefined) {
                    // For flags, ensure value is 0 or 1
                    if (input.category === 'flag') {
                        arr[i] = input.values[i] === 1 || input.values[i] === '1' ? 1 : 0
                    } else {
                        arr[i] = input.values[i]
                    }
                } else {
                    // Calculate value based on category
                    if (input.category === 'indexation') {
                        const indexationPeriod = input.indexationPeriod || 'annual'
                        const rate = input.indexationRate || 0

                        let indexationFactor
                        if (indexationPeriod === 'monthly') {
                            const monthsElapsed = periodTotal - inputStartTotal
                            indexationFactor = Math.pow(1 + rate / MONTHS_IN_YEAR, monthsElapsed)
                        } else {
                            const yearsElapsed = periodYear - inputStartYear
                            indexationFactor = Math.pow(1 + rate, yearsElapsed)
                        }
                        arr[i] = indexationFactor
                    } else if (input.category === 'flag') {
                        if (input.id === -1 || input.name === 'Timeline') {
                            arr[i] = 1
                        } else {
                            arr[i] = isWithinDateRange ? 1 : 0
                        }
                    } else {
                        arr[i] = input.defaultValue
                    }
                }
            }

            arrays[input.id] = arr
        })

        // Second pass: Apply linked flags to value inputs
        allInputs.forEach(input => {
            if (input.category === 'value' && input.linkedFlagId) {
                const flagArray = arrays[input.linkedFlagId]
                if (flagArray) {
                    const arr = arrays[input.id]
                    for (let i = 0; i < timeline.periods; i++) {
                        if (flagArray[i] !== 1) {
                            arr[i] = 0
                        }
                    }
                }
            }
        })

        // Third pass: Apply indexation to value inputs that reference indexation inputs
        allInputs.forEach(input => {
            if (input.category === 'value' && input.indexationInputId && arrays[input.indexationInputId] && arrays[input.id]) {
                const indexationArray = arrays[input.indexationInputId]
                const arr = arrays[input.id]
                for (let i = 0; i < timeline.periods; i++) {
                    arr[i] = arr[i] * indexationArray[i]
                }
            }
        })

        // Fourth pass: Apply formulas
        allInputs.forEach(input => {
            if (input.formula && arrays[input.id]) {
                const arr = arrays[input.id]
                const formula = input.formula.toLowerCase()

                for (let i = 0; i < timeline.periods; i++) {
                    let result = arr[i]

                    if (formula.includes('indexation') && input.indexationRate > 0) {
                        const indexationInput = allInputs.find(inp =>
                            inp.category === 'indexation' && inp.indexationRate === input.indexationRate
                        )
                        if (indexationInput && arrays[indexationInput.id]) {
                            result *= arrays[indexationInput.id][i]
                        }
                    }

                    if (formula.includes('flag') && input.linkedFlagId) {
                        const flagArray = arrays[input.linkedFlagId]
                        if (flagArray) {
                            result *= flagArray[i]
                        }
                    }

                    arr[i] = result
                }
            }
        })

        return arrays
    }, [inputs, timeline, config.startYear, config.startMonth, config.endYear, config.endMonth])

    return {
        inputType1Arrays,
        inputGlassArrays,
        autoGeneratedIndexations,
        autoGeneratedFlags,
        inputArrays
    }
}
