'use client'

import { useMemo } from 'react'

/**
 * Hook to build the reference map for formula evaluation
 * Extracts reference map logic from useDashboardState for better memoization
 *
 * Reference types built:
 * - V, S, C groups (input groups by mode)
 * - F (flags with .Start/.End variants)
 * - I (indexations)
 * - T (time constants like T.DiM, T.MiY)
 * - L (lookups with subgroup support)
 */
export function useReferenceMap({
    inputGlass,
    inputGlassGroups,
    inputGlassArrays,
    autoGeneratedFlags,
    autoGeneratedIndexations,
    timeline
}) {
    // 1. Input Group References (V, S, C groups) - only invalidates when inputs/groups change
    const inputGroupRefs = useMemo(() => {
        const refs = {}

        const activeGroups = inputGlassGroups.filter(group =>
            inputGlass.some(input => input.groupId === group.id)
        )
        const modeIndices = { values: 0, series: 0, constant: 0, timing: 0, lookup: 0 }

        activeGroups.forEach(group => {
            const groupInputs = inputGlass.filter(input => input.groupId === group.id)

            // Determine group mode/type - check groupType first, then fall back to entryMode, then input mode
            let normalizedMode
            if (group.groupType === 'timing') {
                normalizedMode = 'timing'
            } else if (group.groupType === 'constant') {
                normalizedMode = 'constant'
            } else {
                const groupMode = group.entryMode || groupInputs[0]?.mode || 'values'
                if (groupMode === 'lookup' || groupMode === 'lookup2') normalizedMode = 'lookup'
                else normalizedMode = groupMode
            }

            modeIndices[normalizedMode]++
            const modePrefix = normalizedMode === 'timing' ? 'T' :
                              normalizedMode === 'series' ? 'S' :
                              normalizedMode === 'constant' ? 'C' :
                              normalizedMode === 'lookup' ? 'L' : 'V'
            const groupIndex = modeIndices[normalizedMode]
            const groupRef = `${modePrefix}${groupIndex}`

            const groupArrays = groupInputs.map(input =>
                inputGlassArrays[`inputtype3_${input.id}`] || new Array(timeline.periods).fill(0)
            )
            const subtotalArray = new Array(timeline.periods).fill(0)
            for (let i = 0; i < timeline.periods; i++) {
                subtotalArray[i] = groupArrays.reduce((sum, arr) => sum + (arr[i] || 0), 0)
            }
            refs[groupRef] = subtotalArray

            // Use ID-based refs (like R-refs) for stability - deleting an item won't shift other refs
            // For constants (groupId 100): use input.id - 99 (id=100→1, id=118→19, id=123→24)
            // For other groups: use input.id directly
            groupInputs.forEach((input) => {
                const inputNum = group.id === 100 ? input.id - 99 : input.id
                const itemRef = `${groupRef}.${inputNum}`
                refs[itemRef] = inputGlassArrays[`inputtype3_${input.id}`] || new Array(timeline.periods).fill(0)
            })
        })

        return refs
    }, [inputGlass, inputGlassGroups, inputGlassArrays, timeline.periods])

    // 2. Flag References (F1, F2, F1.Start, F1.End, etc.) - ID-based, not position-based
    const flagRefs = useMemo(() => {
        const refs = {}
        Object.values(autoGeneratedFlags).forEach((flag) => {
            // Extract keyPeriod ID from internal key format: flag_keyperiod_{id}
            const idMatch = flag.id?.match(/flag_keyperiod_(\d+)/)
            if (!idMatch) return
            const refNum = parseInt(idMatch[1], 10)
            refs[`F${refNum}`] = flag.array || new Array(timeline.periods).fill(0)
            // Add .Start and .End variants for key period flags
            if (flag.startArray) refs[`F${refNum}.Start`] = flag.startArray
            if (flag.endArray) refs[`F${refNum}.End`] = flag.endArray
        })
        return refs
    }, [autoGeneratedFlags, timeline.periods])

    // 3. Indexation References (I1, I2, etc.) - ID-based, not position-based
    const indexationRefs = useMemo(() => {
        const refs = {}
        Object.values(autoGeneratedIndexations).forEach((indexation) => {
            // Extract index ID from internal key format: index_{id}
            const idMatch = indexation.id?.match(/index_(\d+)/)
            if (!idMatch) return
            const refNum = parseInt(idMatch[1], 10)
            refs[`I${refNum}`] = indexation.array || new Array(timeline.periods).fill(0)
        })
        return refs
    }, [autoGeneratedIndexations, timeline.periods])

    // 4. Time Constant References (T.DiM, T.DiY, etc.) - only invalidates when timeline changes
    const timeConstantRefs = useMemo(() => {
        const refs = {}
        const periods = timeline.periods

        // Cache year-based calculations to avoid redundant computations
        const yearCache = new Map()
        const getYearData = (year) => {
            if (!yearCache.has(year)) {
                const isLeap = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)
                const dec31 = new Date(year, 11, 31)
                const jan1 = new Date(year, 0, 1)
                const weeksInYear = dec31.getDay() === 4 || jan1.getDay() === 4 ? 53 : 52
                yearCache.set(year, { isLeap, weeksInYear, daysInYear: isLeap ? 366 : 365, hoursInYear: isLeap ? 8784 : 8760 })
            }
            return yearCache.get(year)
        }

        const getDaysInMonth = (year, month) => new Date(year, month, 0).getDate()

        // Pre-allocate arrays for variable values (computed in single pass)
        const diM = new Array(periods)   // Days in Month
        const diY = new Array(periods)   // Days in Year
        const wiY = new Array(periods)   // Weeks in Year
        const hiM = new Array(periods)   // Hours in Month
        const hiY = new Array(periods)   // Hours in Year
        const diQ = new Array(periods)   // Days in Quarter
        const qe = new Array(periods)    // Quarter End flag
        const cye = new Array(periods)   // Calendar Year End flag
        const fye = new Array(periods)   // Financial Year End flag

        // Single pass to compute all variable time constants
        for (let i = 0; i < periods; i++) {
            const year = timeline.year[i]
            const month = timeline.month[i]
            const yearData = getYearData(year)
            const daysInMonth = getDaysInMonth(year, month)

            diM[i] = daysInMonth
            diY[i] = yearData.daysInYear
            wiY[i] = yearData.weeksInYear
            hiM[i] = daysInMonth * 24
            hiY[i] = yearData.hoursInYear

            // Days in Quarter
            const quarter = Math.floor((month - 1) / 3)
            const startMonth = quarter * 3 + 1
            diQ[i] = getDaysInMonth(year, startMonth) + getDaysInMonth(year, startMonth + 1) + getDaysInMonth(year, startMonth + 2)

            // Time flags
            qe[i] = (month === 3 || month === 6 || month === 9 || month === 12) ? 1 : 0
            cye[i] = month === 12 ? 1 : 0
            fye[i] = month === 6 ? 1 : 0
        }

        // Variable arrays (computed above)
        refs['T.DiM'] = diM
        refs['T.DiY'] = diY
        refs['T.WiY'] = wiY
        refs['T.HiM'] = hiM
        refs['T.HiY'] = hiY
        refs['T.DiQ'] = diQ
        refs['T.QE'] = qe
        refs['T.CYE'] = cye
        refs['T.FYE'] = fye

        // Constant arrays (same value for all periods - create once with fill)
        refs['T.MiY'] = new Array(periods).fill(12)  // Months in Year
        refs['T.QiY'] = new Array(periods).fill(4)   // Quarters in Year
        refs['T.HiD'] = new Array(periods).fill(24)  // Hours in Day
        refs['T.MiQ'] = new Array(periods).fill(3)   // Months in Quarter

        return refs
    }, [timeline.periods, timeline.year, timeline.month])

    // 5. Lookup References (L1, L1.1, L1.1.1, etc.) - only invalidates when lookups change
    const lookupRefs = useMemo(() => {
        const refs = {}
        let lookupIndex = 0

        inputGlassGroups
            .filter(group => group.entryMode === 'lookup' || group.entryMode === 'lookup2')
            .forEach(group => {
                lookupIndex++
                const groupInputs = inputGlass.filter(input => input.groupId === group.id)
                const lookupRef = `L${lookupIndex}`
                const selectedIndices = group.selectedIndices || {}

                // Group inputs by subgroup
                const subgroups = group.subgroups || []
                const rootInputs = groupInputs.filter(inp => !inp.subgroupId)
                const hasActualSubgroups = subgroups.length > 0

                // If NO subgroups, reference inputs directly as L3.1, L3.2, etc.
                if (!hasActualSubgroups) {
                    rootInputs.forEach((input, inputIdx) => {
                        const inputRef = `${lookupRef}.${inputIdx + 1}`
                        refs[inputRef] = inputGlassArrays[`inputtype3_${input.id}`] || new Array(timeline.periods).fill(0)
                    })
                } else {
                    // WITH subgroups: L3.1 (subgroup), L3.1.1 (input in subgroup), etc.
                    const subgroupedInputs = []
                    if (rootInputs.length > 0) {
                        subgroupedInputs.push({ id: null, name: null, inputs: rootInputs })
                    }
                    subgroups.forEach(sg => {
                        const sgInputs = groupInputs.filter(inp => inp.subgroupId === sg.id)
                        subgroupedInputs.push({ id: sg.id, name: sg.name, inputs: sgInputs })
                    })

                    subgroupedInputs.forEach((sg, sgIdx) => {
                        if (sg.inputs.length === 0) return

                        const key = sg.id ?? 'root'
                        const selectedIdx = selectedIndices[key] ?? 0
                        const selectedInput = sg.inputs[selectedIdx] || sg.inputs[0]
                        const subgroupRef = `${lookupRef}.${sgIdx + 1}`

                        // Add subgroup reference (L1.1) - points to selected input's array
                        if (selectedInput) {
                            refs[subgroupRef] = inputGlassArrays[`inputtype3_${selectedInput.id}`] || new Array(timeline.periods).fill(0)
                        }

                        // Add individual option references (L1.1.1, L1.1.2, etc.)
                        sg.inputs.forEach((input, inputIdx) => {
                            const optionRef = `${subgroupRef}.${inputIdx + 1}`
                            refs[optionRef] = inputGlassArrays[`inputtype3_${input.id}`] || new Array(timeline.periods).fill(0)
                        })
                    })
                }
            })

        return refs
    }, [inputGlass, inputGlassGroups, inputGlassArrays, timeline.periods])

    // 6. COMBINED Reference Map - merges all focused refs
    // Only re-merges when a sub-ref changes, not when unrelated data changes
    const referenceMap = useMemo(() => ({
        ...inputGroupRefs,
        ...flagRefs,
        ...indexationRefs,
        ...timeConstantRefs,
        ...lookupRefs
    }), [inputGroupRefs, flagRefs, indexationRefs, timeConstantRefs, lookupRefs])

    return {
        referenceMap,
        inputGroupRefs,
        flagRefs,
        indexationRefs,
        timeConstantRefs,
        lookupRefs
    }
}
