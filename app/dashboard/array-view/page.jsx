'use client'

import React, { useCallback, useMemo } from 'react'
import { DisplayCell } from '@/components/inputs/Cells'
import { getAggregatedValueForArray } from '../../../utils/valueAggregation'
import { groupInputsBySubgroup, generatePeriods } from '@/components/inputs/utils/inputHelpers'
import { useDashboard } from '../context/DashboardContext'
import { Download } from 'lucide-react'

export default function ArrayViewPage() {
    const {
        viewMode,
        appState,
        setters,
        derived,
        uiState
    } = useDashboard()

    const {
        inputGlass,
        inputGlassGroups,
        modules,
        calculations,
        calculationsTabs,
        calculationsGroups,
        config,
        keyPeriods
    } = appState

    const { setArrayViewSubTab } = setters

    const {
        timeline,
        viewHeaders,
        inputGlassArrays,
        autoGeneratedFlags,
        autoGeneratedIndexations,
        calculationResults,
        referenceTypeMap,
        calculationTypes,
        moduleOutputs
    } = derived

    const { arrayViewSubTab } = uiState

    const calcIndexMap = useMemo(() => {
        const map = new Map()
        ;(calculations || []).forEach(calc => {
            map.set(calc.id, calc.id)
        })
        return map
    }, [calculations])

    const inputsByGroupId = useMemo(() => {
        const map = new Map()
        ;(inputGlass || []).forEach(input => {
            if (!map.has(input.groupId)) {
                map.set(input.groupId, [])
            }
            map.get(input.groupId).push(input)
        })
        return map
    }, [inputGlass])

    const activeInputGroups = useMemo(() => {
        return (inputGlassGroups || []).filter(group => inputsByGroupId.has(group.id))
    }, [inputGlassGroups, inputsByGroupId])

    const buildYearlyHeaders = useCallback(() => {
        const years = []
        const yearMap = new Map()
        for (let i = 0; i < timeline.periods; i++) {
            const year = timeline.year[i]
            if (!yearMap.has(year)) {
                yearMap.set(year, [])
            }
            yearMap.get(year).push(i)
        }
        yearMap.forEach((indices, year) => {
            years.push({ year, indices })
        })
        return years
    }, [timeline])

    const handleExportDebug = useCallback(async (exportMonthly = false) => {
        const yearlyHeaders = buildYearlyHeaders()
        const debugData = {
            exportedAt: new Date().toISOString(),
            granularity: exportMonthly ? 'monthly' : 'yearly',
            timeline: {
                startYear: config.startYear,
                startMonth: config.startMonth,
                endYear: config.endYear,
                endMonth: config.endMonth,
                periods: timeline.periods
            },
            years: yearlyHeaders.map(h => h.year),
            inputs: {},
            calculations: {}
        }

        const modeIndices = { values: 0, series: 0, constant: 0, timing: 0 }

        Object.values(autoGeneratedFlags).forEach((flag) => {
            const idMatch = flag.id?.match(/flag_keyperiod_(\d+)/)
            if (!idMatch) return
            const ref = `F${idMatch[1]}`
            debugData.inputs[ref] = {
                name: flag.name,
                type: 'flag',
                yearly: exportMonthly
                    ? [...flag.array]
                    : yearlyHeaders.map(h => getAggregatedValueForArray(flag.array, h.indices, 'flow', 'flag'))
            }
        })

        Object.values(autoGeneratedIndexations).forEach((indexation) => {
            const idMatch = indexation.id?.match(/index_(\d+)/)
            if (!idMatch) return
            const ref = `I${idMatch[1]}`
            debugData.inputs[ref] = {
                name: indexation.name,
                type: 'indexation',
                yearly: exportMonthly
                    ? [...indexation.array]
                    : yearlyHeaders.map(h => getAggregatedValueForArray(indexation.array, h.indices, 'stock'))
            }
        })

        const activeGroups = inputGlassGroups.filter(group =>
            inputGlass.some(input => input.groupId === group.id)
        )

        activeGroups.forEach(group => {
            const groupInputs = inputGlass.filter(input => input.groupId === group.id)
            let normalizedMode
            if (group.groupType === 'timing') {
                normalizedMode = 'timing'
            } else if (group.groupType === 'constant') {
                normalizedMode = 'constant'
            } else {
                const groupMode = group.entryMode || groupInputs[0]?.mode || 'values'
                if (groupMode === 'lookup' || groupMode === 'lookup2') normalizedMode = 'lookup'
                else normalizedMode = groupMode
            }
            modeIndices[normalizedMode]++
            const modePrefix = normalizedMode === 'timing' ? 'T' :
                              normalizedMode === 'series' ? 'S' :
                              normalizedMode === 'constant' ? 'C' :
                              normalizedMode === 'lookup' ? 'L' : 'V'
            const groupRef = `${modePrefix}${modeIndices[normalizedMode]}`
            const groupType = referenceTypeMap?.[groupRef] || 'flow'

            const groupTotals = exportMonthly
                ? (() => {
                    const totals = new Array(timeline.periods).fill(0)
                    groupInputs.forEach(input => {
                        const arr = inputGlassArrays[`inputtype3_${input.id}`] || []
                        for (let i = 0; i < timeline.periods; i++) {
                            totals[i] += arr[i] || 0
                        }
                    })
                    return totals
                })()
                : yearlyHeaders.map(h => {
                    return groupInputs.reduce((sum, input) => {
                        const arr = inputGlassArrays[`inputtype3_${input.id}`] || []
                        return sum + getAggregatedValueForArray(arr, h.indices, groupType)
                    }, 0)
                })

            debugData.inputs[groupRef] = {
                name: group.name,
                type: groupType,
                yearly: groupTotals
            }

            groupInputs.forEach((input) => {
                const inputNum = group.id === 100 ? input.id - 99 : input.id
                const inputRef = `${groupRef}.${inputNum}`
                const inputType = referenceTypeMap?.[inputRef] || groupType
                const arr = inputGlassArrays[`inputtype3_${input.id}`] || []
                debugData.inputs[inputRef] = {
                    name: input.name,
                    type: inputType,
                    yearly: exportMonthly
                        ? [...arr]
                        : yearlyHeaders.map(h => getAggregatedValueForArray(arr, h.indices, inputType))
                }
            })
        })

        const lookupGroups = inputGlassGroups.filter(g =>
            g.entryMode === 'lookup' || g.entryMode === 'lookup2'
        )

        lookupGroups.forEach((group, idx) => {
            const groupInputs = inputGlass.filter(input => input.groupId === group.id)
            const lookupRef = `L${idx + 1}`
            const lookupType = referenceTypeMap?.[lookupRef] || 'stock'
            if (groupInputs.length === 0) return
            const subgroupedInputs = groupInputsBySubgroup(groupInputs, group)
            const selectedIndices = group.selectedIndices || {}
            subgroupedInputs.forEach((sg, sgIdx) => {
                if (sg.inputs.length === 0) return
                const key = sg.id ?? 'root'
                const selectedIdx = selectedIndices[key] ?? 0
                const selectedInput = sg.inputs[selectedIdx] || sg.inputs[0]
                if (!selectedInput) return
                const subgroupRef = `${lookupRef}.${sgIdx + 1}`
                const arr = inputGlassArrays[`inputtype3_${selectedInput.id}`] || []
                debugData.inputs[subgroupRef] = {
                    name: `${sg.name ? sg.name + ': ' : ''}${selectedInput.name}`,
                    type: lookupType,
                    yearly: exportMonthly
                        ? [...arr]
                        : yearlyHeaders.map(h => getAggregatedValueForArray(arr, h.indices, lookupType))
                }
            })
        })

        ;(calculations || []).forEach(calc => {
            const calcRef = `R${calcIndexMap.get(calc.id)}`
            const resultArray = calculationResults[calcRef] || []
            const calcType = calculationTypes?.[calcRef] || 'flow'
            debugData.calculations[calcRef] = {
                name: calc.name,
                formula: calc.formula,
                type: calcType,
                yearly: exportMonthly
                    ? [...resultArray]
                    : yearlyHeaders.map(h => getAggregatedValueForArray(resultArray, h.indices, calcType))
            }
        })

        const suffix = exportMonthly ? '&monthly=true' : ''
        try {
            const response = await fetch(`/api/debug-export?compact=true${suffix}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(debugData)
            })
            const result = await response.json()
            if (result.success) {
                const granLabel = exportMonthly ? 'monthly' : 'yearly'
                alert(`Debug data exported (${granLabel}): ${result.filename} (${result.sizeKB} KB${result.compact ? ', compact' : ''})`)
            } else {
                alert(`Export failed: ${result.error}`)
            }
        } catch (error) {
            console.error('Export error:', error)
            alert(`Export failed: ${error.message}`)
        }
    }, [
        buildYearlyHeaders, config, timeline, autoGeneratedFlags, autoGeneratedIndexations,
        inputGlass, inputGlassGroups, inputGlassArrays, referenceTypeMap,
        calculations, calculationResults, calculationTypes, calcIndexMap
    ])

    return (
        <main className="max-w-[1800px] mx-auto px-6 py-6">
            <div className="bg-white border border-slate-200 rounded-xl overflow-hidden shadow-lg">
                {/* Header */}
                <div className="bg-slate-50 border-b border-slate-200 px-6 py-3">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-4">
                            <h2 className="text-lg font-semibold text-slate-900">Array View</h2>
                            <div className="flex bg-slate-200 p-0.5 rounded-lg">
                                {[
                                    { id: 'inputs', label: 'Inputs' },
                                    { id: 'modules', label: 'Modules' },
                                    { id: 'results', label: 'Results' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setArrayViewSubTab(tab.id)}
                                        className={`px-3 py-1 rounded text-xs font-semibold transition-all ${
                                            arrayViewSubTab === tab.id
                                                ? 'bg-indigo-600 text-white shadow-sm'
                                                : 'text-slate-600 hover:text-slate-900'
                                        }`}
                                    >
                                        {tab.label}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div className="flex items-center gap-1">
                            <button
                                onClick={() => handleExportDebug(false)}
                                className="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-slate-600 hover:text-slate-900 bg-slate-100 hover:bg-slate-200 rounded-l-lg border border-slate-200 transition-colors"
                                title="Export yearly aggregated debug data"
                            >
                                <Download className="w-3.5 h-3.5" />
                                Yearly
                            </button>
                            <button
                                onClick={() => handleExportDebug(true)}
                                className="flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-slate-600 hover:text-slate-900 bg-slate-100 hover:bg-slate-200 rounded-r-lg border border-slate-200 border-l-0 transition-colors"
                                title="Export monthly granular debug data"
                            >
                                Monthly
                            </button>
                        </div>
                    </div>
                </div>

                {/* Table */}
                <div className="overflow-x-auto overflow-y-auto" style={{ maxHeight: 'calc(100vh - 260px)' }}>
                    <table className="w-full border-collapse text-[11px]" style={{ minWidth: viewMode === 'M' ? `${270 + viewHeaders.length * 55}px` : '100%' }}>
                        <thead className="sticky top-0 z-30">
                            <tr className="bg-slate-100 border-b border-slate-300">
                                <th className="sticky left-0 z-40 w-[200px] min-w-[200px] px-3 py-2 text-left bg-slate-100 border-r border-slate-300">
                                    <span className="text-[10px] font-semibold text-slate-500 uppercase tracking-wider">
                                        {arrayViewSubTab === 'inputs' ? 'Input Arrays' : arrayViewSubTab === 'modules' ? 'Module Outputs' : 'Calculation Results'}
                                    </span>
                                </th>
                                <th className="sticky left-[200px] z-40 min-w-[70px] px-0.5 py-2 text-center bg-slate-200 border-r border-slate-300">
                                    <span className="text-[10px] font-bold text-slate-600">Total</span>
                                </th>
                                {viewHeaders.map((header, i) => (
                                    <th key={i} className="px-0.5 py-2 text-center min-w-[55px] bg-slate-100">
                                        <span className="text-[10px] font-semibold text-slate-500">{header.label}</span>
                                    </th>
                                ))}
                            </tr>
                        </thead>
                        <tbody>
                            {arrayViewSubTab === 'inputs' && (
                                <InputsSubTab
                                    inputGlass={inputGlass}
                                    inputGlassGroups={inputGlassGroups}
                                    inputGlassArrays={inputGlassArrays}
                                    autoGeneratedFlags={autoGeneratedFlags}
                                    autoGeneratedIndexations={autoGeneratedIndexations}
                                    timeline={timeline}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                    referenceTypeMap={referenceTypeMap}
                                    config={config}
                                    keyPeriods={keyPeriods}
                                    activeInputGroups={activeInputGroups}
                                    inputsByGroupId={inputsByGroupId}
                                />
                            )}
                            {arrayViewSubTab === 'modules' && (
                                <ModulesSubTab
                                    modules={modules}
                                    moduleOutputs={moduleOutputs}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                />
                            )}
                            {arrayViewSubTab === 'results' && (
                                <ResultsSubTab
                                    calculations={calculations}
                                    calculationsTabs={calculationsTabs}
                                    calculationsGroups={calculationsGroups}
                                    calculationResults={calculationResults}
                                    calculationTypes={calculationTypes}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                    calcIndexMap={calcIndexMap}
                                />
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        </main>
    )
}

// Shared: section header row
function SectionHeader({ label, viewHeaders, color = 'slate' }) {
    const bgClass = color === 'slate' ? 'bg-slate-200' : color === 'indigo' ? 'bg-indigo-50' : 'bg-slate-200'
    const textClass = color === 'slate' ? 'text-slate-600' : color === 'indigo' ? 'text-indigo-800' : 'text-slate-600'
    const borderClass = color === 'slate' ? 'border-slate-300' : color === 'indigo' ? 'border-indigo-200' : 'border-slate-300'
    return (
        <tr className={`${bgClass} border-b ${borderClass}`}>
            <td className={`sticky left-0 z-20 w-[200px] min-w-[200px] border-r ${borderClass} px-3 py-1.5 ${bgClass}`}>
                <span className={`text-[10px] font-bold ${textClass} uppercase tracking-wider`}>{label}</span>
            </td>
            <td className={`sticky left-[200px] z-20 min-w-[70px] ${bgClass} border-r ${borderClass}`}></td>
            {viewHeaders.map((_, i) => (
                <td key={i} className={`min-w-[55px] ${bgClass}`}></td>
            ))}
        </tr>
    )
}

// Shared: group header row
function GroupHeader({ refLabel, name, count, viewHeaders, colorScheme = 'purple', cells, totalValue }) {
    const colors = {
        purple: { badge: 'text-purple-600 bg-purple-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        green: { badge: 'text-green-600 bg-green-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        blue: { badge: 'text-blue-600 bg-blue-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        teal: { badge: 'text-teal-600 bg-teal-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        amber: { badge: 'text-amber-600 bg-amber-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        lime: { badge: 'text-lime-600 bg-lime-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        orange: { badge: 'text-orange-600 bg-orange-100', bg: 'bg-slate-50', border: 'border-slate-200' },
        rose: { badge: 'text-rose-600 bg-rose-100', bg: 'bg-rose-50/50', border: 'border-rose-200' },
    }
    const c = colors[colorScheme] || colors.purple
    return (
        <tr className={`${c.bg} border-b ${c.border}`}>
            <td className={`sticky left-0 z-20 w-[200px] min-w-[200px] border-r ${c.border} px-3 py-1 ${c.bg}`}>
                <div className="flex items-center gap-1.5">
                    <span className={`text-[10px] px-1 py-0 rounded font-semibold ${c.badge}`}>{refLabel}</span>
                    <span className="text-[11px] font-semibold text-slate-900 truncate">{name}</span>
                    {count != null && <span className="text-[10px] text-slate-400">({count})</span>}
                </div>
            </td>
            <td className={`sticky left-[200px] z-20 min-w-[70px] h-[22px] p-0 bg-slate-100 border-r ${c.border}`}>
                {totalValue != null && <DisplayCell value={totalValue} category="value" isTimeline={false} />}
            </td>
            {cells || viewHeaders.map((_, i) => (
                <td key={i} className={`min-w-[55px] h-[22px] p-0 ${c.bg}`}></td>
            ))}
        </tr>
    )
}

// Shared: data row
function DataRow({ refLabel, name, viewHeaders, viewMode, dataArray, dataType = 'flow', colorScheme = 'purple', indent = false, suffix }) {
    const colors = {
        purple: { badge: 'text-purple-500 bg-purple-50', category: 'value' },
        green: { badge: 'text-green-500 bg-green-50', category: 'value' },
        blue: { badge: 'text-blue-500 bg-blue-50', category: 'value' },
        teal: { badge: 'text-teal-500 bg-teal-50', category: 'value' },
        amber: { badge: 'text-amber-600 bg-amber-50', category: 'value' },
        lime: { badge: 'text-lime-600 bg-lime-50', category: 'value' },
        orange: { badge: 'text-orange-500 bg-orange-50', category: 'module' },
        rose: { badge: 'text-rose-600 bg-rose-100', category: 'result' },
        flag: { badge: 'text-amber-600 bg-amber-100', category: 'flag' },
        index: { badge: 'text-cyan-600 bg-cyan-100', category: 'indexation' },
    }
    const c = colors[colorScheme] || colors.purple
    const isMonthly = viewMode === 'M'
    const isFlag = c.category === 'flag'

    // Calculate total: sum for flows, last value for stocks, skip for flags
    const totalValue = isFlag ? null : (
        dataType === 'stock'
            ? (dataArray[dataArray.length - 1] ?? 0)
            : dataArray.reduce((sum, v) => sum + (v || 0), 0)
    )

    return (
        <tr className="hover:bg-blue-50/30 border-b border-slate-100">
            <td className={`sticky left-0 z-20 w-[200px] min-w-[200px] border-r border-slate-200 py-0.5 bg-white ${indent ? 'px-3 pl-6' : 'px-3'}`}>
                <div className="flex items-center gap-1.5">
                    <span className={`text-[10px] px-1 py-0 rounded font-medium ${c.badge}`}>{refLabel}</span>
                    <span className="text-[11px] text-slate-700 truncate">{name}</span>
                    {suffix && <span className="text-[9px] text-slate-400">{suffix}</span>}
                </div>
            </td>
            <td className="sticky left-[200px] z-20 min-w-[70px] h-[22px] p-0 bg-slate-50 border-r border-slate-200">
                {totalValue != null && <DisplayCell value={totalValue} category={c.category} isTimeline={false} />}
            </td>
            {viewHeaders.map((header, i) => {
                const cellValue = isMonthly
                    ? (dataArray[header.index] ?? 0)
                    : getAggregatedValueForArray(dataArray, header.indices, dataType, isFlag ? 'flag' : undefined)
                return (
                    <td key={i} className="min-w-[55px] h-[22px] p-0">
                        <DisplayCell value={cellValue} category={c.category} isTimeline={false} />
                    </td>
                )
            })}
        </tr>
    )
}

function InputsSubTab({
    inputGlass,
    inputGlassGroups,
    inputGlassArrays,
    autoGeneratedFlags,
    autoGeneratedIndexations,
    timeline,
    viewHeaders,
    viewMode,
    referenceTypeMap,
    config,
    keyPeriods = [],
    activeInputGroups,
    inputsByGroupId
}) {
    const isMonthly = viewMode === 'M'

    return (
        <>
            {/* Timing */}
            {(Object.keys(autoGeneratedFlags).length > 0 || Object.keys(autoGeneratedIndexations).length > 0) && (
                <>
                    <SectionHeader label="Timing" viewHeaders={viewHeaders} />

                    {Object.values(autoGeneratedFlags).map((flag) => {
                        const idMatch = flag.id?.match(/flag_keyperiod_(\d+)/)
                        if (!idMatch) return null
                        return (
                            <DataRow
                                key={flag.id}
                                refLabel={`F${idMatch[1]}`}
                                name={flag.name}
                                viewHeaders={viewHeaders}
                                viewMode={viewMode}
                                dataArray={flag.array}
                                dataType="flow"
                                colorScheme="flag"
                            />
                        )
                    })}

                    {Object.values(autoGeneratedIndexations).map((indexation) => {
                        const idMatch = indexation.id?.match(/index_(\d+)/)
                        if (!idMatch) return null
                        return (
                            <DataRow
                                key={indexation.id}
                                refLabel={`I${idMatch[1]}`}
                                name={indexation.name}
                                viewHeaders={viewHeaders}
                                viewMode={viewMode}
                                dataArray={indexation.array}
                                dataType="stock"
                                colorScheme="index"
                            />
                        )
                    })}
                </>
            )}

            {/* Inputs */}
            {activeInputGroups.length > 0 && (
                <>
                    <SectionHeader label="Inputs" viewHeaders={viewHeaders} />

                    {(() => {
                        const modeIndices = { values: 0, series: 0, constant: 0, timing: 0 }

                        return activeInputGroups.map((group) => {
                            const groupInputs = inputsByGroupId.get(group.id) || []

                            let normalizedMode
                            if (group.groupType === 'timing') {
                                normalizedMode = 'timing'
                            } else if (group.groupType === 'constant') {
                                normalizedMode = 'constant'
                            } else {
                                const groupMode = group.entryMode || groupInputs[0]?.mode || 'values'
                                if (groupMode === 'lookup' || groupMode === 'lookup2') normalizedMode = 'lookup'
                                else normalizedMode = groupMode
                            }

                            modeIndices[normalizedMode]++
                            const modePrefix = normalizedMode === 'timing' ? 'T' :
                                              normalizedMode === 'series' ? 'S' :
                                              normalizedMode === 'constant' ? 'C' :
                                              normalizedMode === 'lookup' ? 'L' : 'V'
                            const groupRef = `${modePrefix}${modeIndices[normalizedMode]}`
                            const groupType = referenceTypeMap?.[groupRef] || 'flow'
                            const colorScheme = normalizedMode === 'timing' ? 'teal' :
                                               normalizedMode === 'series' ? 'green' :
                                               normalizedMode === 'constant' ? 'blue' : 'purple'

                            const inputMonthlyArrays = groupInputs.map(input =>
                                inputGlassArrays[`inputtype3_${input.id}`] || new Array(timeline.periods).fill(0)
                            )

                            // Calculate group total across all periods
                            const groupTotalValue = groupType === 'stock' ? (() => {
                                let last = 0
                                inputMonthlyArrays.forEach(arr => { last += (arr[arr.length - 1] || 0) })
                                return last
                            })() : (() => {
                                let sum = 0
                                inputMonthlyArrays.forEach(arr => {
                                    for (let i = 0; i < arr.length; i++) sum += (arr[i] || 0)
                                })
                                return sum
                            })()

                            return (
                                <React.Fragment key={group.id}>
                                    {/* Group total */}
                                    <GroupHeader
                                        refLabel={groupRef}
                                        name={group.name}
                                        count={groupInputs.length}
                                        viewHeaders={viewHeaders}
                                        colorScheme={colorScheme}
                                        totalValue={groupTotalValue}
                                        cells={viewHeaders.map((header, colIndex) => {
                                            let cellValue = 0
                                            inputMonthlyArrays.forEach(arr => {
                                                cellValue += isMonthly
                                                    ? (arr[header.index] ?? 0)
                                                    : getAggregatedValueForArray(arr, header.indices, groupType)
                                            })
                                            return (
                                                <td key={colIndex} className="min-w-[55px] h-[22px] p-0 bg-slate-50">
                                                    <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                                </td>
                                            )
                                        })}
                                    />
                                    {/* Individual inputs */}
                                    {groupInputs.map((input, idx) => {
                                        const inputNum = group.id === 100 ? input.id - 99 : input.id
                                        return (
                                            <DataRow
                                                key={input.id}
                                                refLabel={`${groupRef}.${inputNum}`}
                                                name={input.name}
                                                viewHeaders={viewHeaders}
                                                viewMode={viewMode}
                                                dataArray={inputMonthlyArrays[idx] || []}
                                                dataType={groupType}
                                                colorScheme={colorScheme}
                                                indent
                                            />
                                        )
                                    })}
                                </React.Fragment>
                            )
                        })
                    })()}
                </>
            )}

            {/* Lookups */}
            {(() => {
                const lookupGroups = inputGlassGroups.filter(g => g.entryMode === 'lookup' || g.entryMode === 'lookup2')
                if (lookupGroups.length === 0) return null

                return (
                    <>
                        <SectionHeader label="Lookups" viewHeaders={viewHeaders} />
                        {lookupGroups.map((group, idx) => {
                            const groupInputs = inputGlass.filter(input => input.groupId === group.id)
                            const lookupRef = `L${idx + 1}`
                            if (groupInputs.length === 0) return null
                            const subgroupedInputs = groupInputsBySubgroup(groupInputs, group)
                            const selectedIndices = group.selectedIndices || {}
                            const lookupType = referenceTypeMap?.[lookupRef] || 'stock'

                            return (
                                <React.Fragment key={group.id}>
                                    <GroupHeader
                                        refLabel={lookupRef}
                                        name={group.name}
                                        count={groupInputs.length}
                                        viewHeaders={viewHeaders}
                                        colorScheme="lime"
                                    />
                                    {subgroupedInputs.map((sg, sgIdx) => {
                                        if (sg.inputs.length === 0) return null
                                        const key = sg.id ?? 'root'
                                        const selectedIdx = selectedIndices[key] ?? 0
                                        const selectedInput = sg.inputs[selectedIdx] || sg.inputs[0]
                                        if (!selectedInput) return null
                                        const arr = inputGlassArrays[`inputtype3_${selectedInput.id}`] || new Array(timeline.periods).fill(0)
                                        const displayName = sg.name ? `${sg.name}: ${selectedInput.name}` : selectedInput.name

                                        return (
                                            <DataRow
                                                key={sg.id ?? 'root'}
                                                refLabel={`${lookupRef}.${sgIdx + 1}`}
                                                name={displayName}
                                                viewHeaders={viewHeaders}
                                                viewMode={viewMode}
                                                dataArray={arr}
                                                dataType={lookupType}
                                                colorScheme="lime"
                                                indent
                                            />
                                        )
                                    })}
                                </React.Fragment>
                            )
                        })}
                    </>
                )
            })()}
        </>
    )
}

function ModulesSubTab({ modules, moduleOutputs, viewHeaders, viewMode }) {
    if (!modules || modules.length === 0) {
        return (
            <tr>
                <td colSpan={viewHeaders.length + 1} className="text-center py-12 text-sm text-slate-400">
                    No modules added yet
                </td>
            </tr>
        )
    }

    return (
        <>
            {modules.map((module, moduleIdx) => (
                <React.Fragment key={module.id}>
                    <GroupHeader
                        refLabel={`M${moduleIdx + 1}`}
                        name={module.name}
                        count={module.outputs?.length}
                        viewHeaders={viewHeaders}
                        colorScheme="orange"
                    />
                    {module.outputs && module.outputs.map((output, outputIdx) => {
                        const outputRef = `M${moduleIdx + 1}.${outputIdx + 1}`
                        const outputArray = moduleOutputs?.[outputRef] || []
                        const outputLabel = typeof output === 'string' ? output : output.label || output
                        const displayName = (typeof outputLabel === 'string' ? outputLabel : '').replace(/_/g, ' ')

                        return (
                            <DataRow
                                key={outputRef}
                                refLabel={outputRef}
                                name={displayName}
                                viewHeaders={viewHeaders}
                                viewMode={viewMode}
                                dataArray={outputArray}
                                dataType="flow"
                                colorScheme="orange"
                                indent
                            />
                        )
                    })}
                </React.Fragment>
            ))}
        </>
    )
}

function ResultsSubTab({ calculations, calculationsTabs, calculationsGroups, calculationResults, calculationTypes, viewHeaders, viewMode, calcIndexMap }) {
    if (!calculations || calculations.length === 0) {
        return (
            <tr>
                <td colSpan={viewHeaders.length + 1} className="text-center py-12 text-sm text-slate-400">
                    No calculations yet
                </td>
            </tr>
        )
    }

    const isMonthly = viewMode === 'M'

    const renderCalcRow = (calc, indent = false) => {
        const calcRef = `R${calcIndexMap.get(calc.id)}`
        const resultArray = calculationResults[calcRef] || []
        const calcType = calculationTypes?.[calcRef] || 'flow'
        return (
            <DataRow
                key={calc.id}
                refLabel={calcRef}
                name={calc.name}
                viewHeaders={viewHeaders}
                viewMode={viewMode}
                dataArray={resultArray}
                dataType={calcType}
                colorScheme="rose"
                indent={indent}
                suffix={calcType === 'stock' ? 'stock' : null}
            />
        )
    }

    const renderGroupHeader = (group, groupCalcs) => {
        // Calculate grand total for the group (sum of all flow calcs across all periods)
        let groupGrandTotal = 0
        groupCalcs.forEach(calc => {
            const calcRef = `R${calcIndexMap.get(calc.id)}`
            const resultArray = calculationResults[calcRef] || []
            const calcType = calculationTypes?.[calcRef] || 'flow'
            if (calcType === 'stock') return
            for (let i = 0; i < resultArray.length; i++) groupGrandTotal += (resultArray[i] || 0)
        })

        const groupCells = viewHeaders.map((header, colIndex) => {
            const subtotal = groupCalcs.reduce((sum, calc) => {
                const calcRef = `R${calcIndexMap.get(calc.id)}`
                const resultArray = calculationResults[calcRef] || []
                const calcType = calculationTypes?.[calcRef] || 'flow'
                if (calcType === 'stock') return sum
                return sum + (isMonthly
                    ? (resultArray[header.index] ?? 0)
                    : getAggregatedValueForArray(resultArray, header.indices || [header.index], calcType))
            }, 0)
            return (
                <td key={colIndex} className="min-w-[55px] h-[22px] p-0 bg-rose-50/50">
                    <DisplayCell value={subtotal} category="result" isTimeline={false} />
                </td>
            )
        })

        return (
            <GroupHeader
                key={`group-${group.id}`}
                refLabel=""
                name={group.name}
                viewHeaders={viewHeaders}
                colorScheme="rose"
                totalValue={groupGrandTotal}
                cells={groupCells}
            />
        )
    }

    const firstTabId = (calculationsTabs || [])[0]?.id

    return (
        <>
            {(calculationsTabs || []).map((tab) => {
                const isFirstTab = tab.id === firstTabId
                const tabGroups = (calculationsGroups || []).filter(g =>
                    g.tabId === tab.id || (isFirstTab && !g.tabId)
                )
                const tabCalcs = calculations.filter(c =>
                    c.tabId === tab.id || (isFirstTab && !c.tabId)
                )
                if (tabCalcs.length === 0) return null

                return (
                    <React.Fragment key={tab.id}>
                        <SectionHeader label={tab.name} viewHeaders={viewHeaders} color="indigo" />

                        {tabGroups.map((group) => {
                            const groupCalcs = tabCalcs.filter(c => c.groupId === group.id)
                            if (groupCalcs.length === 0) return null
                            return (
                                <React.Fragment key={group.id}>
                                    {renderGroupHeader(group, groupCalcs)}
                                    {groupCalcs.map(calc => renderCalcRow(calc, true))}
                                </React.Fragment>
                            )
                        })}

                        {tabCalcs
                            .filter(c => !c.groupId || !tabGroups.some(g => g.id === c.groupId))
                            .map(calc => renderCalcRow(calc, false))
                        }
                    </React.Fragment>
                )
            })}

            {(() => {
                const orphanedCalcs = calculations.filter(c =>
                    c.tabId && !(calculationsTabs || []).some(t => t.id === c.tabId)
                )
                if (orphanedCalcs.length === 0) return null
                const orphanedGroups = (calculationsGroups || []).filter(g =>
                    g.tabId && !(calculationsTabs || []).some(t => t.id === g.tabId)
                )
                return (
                    <>
                        {orphanedGroups.map((group) => {
                            const groupCalcs = orphanedCalcs.filter(c => c.groupId === group.id)
                            if (groupCalcs.length === 0) return null
                            return (
                                <React.Fragment key={group.id}>
                                    {renderGroupHeader(group, groupCalcs)}
                                    {groupCalcs.map(calc => renderCalcRow(calc, true))}
                                </React.Fragment>
                            )
                        })}
                        {orphanedCalcs
                            .filter(c => !c.groupId || !orphanedGroups.some(g => g.id === c.groupId))
                            .map(calc => renderCalcRow(calc, false))
                        }
                    </>
                )
            })()}
        </>
    )
}
