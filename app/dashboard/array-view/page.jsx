'use client'

import React from 'react'
import { DisplayCell } from '@/components/inputs/Cells'
import { getAggregatedValueForArray } from '../../../utils/valueAggregation'
import { useDashboard } from '../context/DashboardContext'
import {
    getValuesArray,
    generatePeriods,
    getMonthsPerPeriod
} from '@/components/inputs/utils/inputHelpers'

export default function ArrayViewPage() {
    const {
        viewMode,
        appState,
        setters,
        derived,
        uiState
    } = useDashboard()

    const {
        inputGlass,
        inputGlassGroups,
        modules,
        calculations,
        config,
        keyPeriods
    } = appState

    const { setArrayViewSubTab } = setters

    const {
        timeline,
        viewHeaders,
        inputGlassArrays,
        autoGeneratedFlags,
        autoGeneratedIndexations,
        calculationResults,
        referenceTypeMap,
        calculationTypes
    } = derived

    const { arrayViewSubTab } = uiState

    return (
        <main className="max-w-[1800px] mx-auto px-6 py-6">
            <div className="bg-white backdrop-blur border border-slate-200 rounded-xl overflow-hidden shadow-lg">
                {/* Array View Header with Sub-tabs */}
                <div className="bg-slate-50 border-b border-slate-200 px-6 py-4">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-4">
                            <h2 className="text-lg font-semibold text-slate-900">Array View</h2>
                            <span className={`text-xs font-semibold px-2 py-0.5 rounded ${
                                viewMode === 'M' ? 'bg-indigo-100 text-indigo-700' :
                                viewMode === 'Q' ? 'bg-emerald-100 text-emerald-700' :
                                viewMode === 'Y' ? 'bg-amber-100 text-amber-700' :
                                'bg-purple-100 text-purple-700'
                            }`}>
                                {viewMode === 'M' ? 'Monthly' : viewMode === 'Q' ? 'Quarterly' : viewMode === 'Y' ? 'Yearly' : 'Financial Year'}
                            </span>
                            {/* Sub-tabs */}
                            <div className="flex bg-slate-200 p-1 rounded-lg">
                                {[
                                    { id: 'inputs', label: 'Inputs' },
                                    { id: 'modules', label: 'Modules' },
                                    { id: 'results', label: 'Results' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setArrayViewSubTab(tab.id)}
                                        className={`px-3 py-1 rounded text-sm font-medium transition-all ${
                                            arrayViewSubTab === tab.id
                                                ? 'bg-white text-slate-900 shadow-sm'
                                                : 'text-slate-600 hover:text-slate-900'
                                        }`}
                                    >
                                        {tab.label}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>

                {/* Array View Content */}
                <div className="overflow-x-auto overflow-y-auto scrollbar-thin" style={{ maxHeight: 'calc(100vh - 300px)' }}>
                    <table className="glass-grid w-full border-collapse" style={{ minWidth: viewMode === 'M' ? `${600 + viewHeaders.length * 90}px` : '100%' }}>
                        <thead className="sticky top-0 z-30">
                            <tr className="bg-slate-100">
                                <th className="frozen-col w-[300px] min-w-[300px] px-4 py-3 text-left border-b border-r border-slate-600 bg-slate-100">
                                    <span className="text-xs font-semibold text-slate-400 uppercase tracking-wider">
                                        {arrayViewSubTab === 'inputs' ? 'Input Groups' : arrayViewSubTab === 'modules' ? 'Modules' : 'Calculations'}
                                    </span>
                                </th>
                                {viewHeaders.map((header, i) => (
                                    <th key={i} className="px-2 py-3 text-center border-b border-slate-600 min-w-[90px] bg-slate-100">
                                        <span className="text-xs font-semibold text-slate-400">{header.label}</span>
                                    </th>
                                ))}
                            </tr>
                        </thead>
                        <tbody>
                            {/* Inputs Sub-tab */}
                            {arrayViewSubTab === 'inputs' && (
                                <InputsSubTab
                                    inputGlass={inputGlass}
                                    inputGlassGroups={inputGlassGroups}
                                    inputGlassArrays={inputGlassArrays}
                                    autoGeneratedFlags={autoGeneratedFlags}
                                    autoGeneratedIndexations={autoGeneratedIndexations}
                                    timeline={timeline}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                    referenceTypeMap={referenceTypeMap}
                                    config={config}
                                    keyPeriods={keyPeriods}
                                />
                            )}

                            {/* Modules Sub-tab */}
                            {arrayViewSubTab === 'modules' && (
                                <ModulesSubTab
                                    modules={modules}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                />
                            )}

                            {/* Results Sub-tab */}
                            {arrayViewSubTab === 'results' && (
                                <ResultsSubTab
                                    calculations={calculations}
                                    calculationResults={calculationResults}
                                    calculationTypes={calculationTypes}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                />
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        </main>
    )
}

function InputsSubTab({
    inputGlass,
    inputGlassGroups,
    inputGlassArrays,
    autoGeneratedFlags,
    autoGeneratedIndexations,
    timeline,
    viewHeaders,
    viewMode,
    referenceTypeMap,
    config,
    keyPeriods = []
}) {
    return (
        <>
            {/* Timing Section */}
            {(Object.keys(autoGeneratedFlags).length > 0 || Object.keys(autoGeneratedIndexations).length > 0) && (
                <>
                    {/* Timing Section Header */}
                    <tr className="bg-slate-200 border-b border-slate-300">
                        <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-300 px-4 py-2">
                            <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">Timing</span>
                        </td>
                        {viewHeaders.map((_, colIndex) => (
                            <td key={colIndex} className="min-w-[90px] h-[36px] bg-slate-200"></td>
                        ))}
                    </tr>

                    {/* Flags */}
                    {Object.values(autoGeneratedFlags).map((flag, idx) => (
                        <tr key={flag.id} className="hover:bg-slate-50 transition-colors border-b border-slate-200">
                            <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-2 pl-6">
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-amber-600 bg-amber-100 px-1.5 py-0.5 rounded font-medium">F{idx + 1}</span>
                                    <span className="text-sm font-medium text-slate-900">{flag.name}</span>
                                </div>
                            </td>
                            {viewHeaders.map((header, colIndex) => {
                                const isMonthlyView = viewMode === 'M'
                                const cellValue = isMonthlyView
                                    ? (flag.array[header.index] ?? 0)
                                    : getAggregatedValueForArray(flag.array, header.indices, 'flow', 'flag')
                                return (
                                    <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[36px] p-0">
                                        <DisplayCell value={cellValue} category="flag" isTimeline={false} />
                                    </td>
                                )
                            })}
                        </tr>
                    ))}

                    {/* Indexations */}
                    {Object.values(autoGeneratedIndexations).map((indexation, idx) => (
                        <tr key={indexation.id} className="hover:bg-slate-50 transition-colors border-b border-slate-200">
                            <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-2 pl-6">
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-cyan-600 bg-cyan-100 px-1.5 py-0.5 rounded font-medium">I{idx + 1}</span>
                                    <span className="text-sm font-medium text-slate-900">{indexation.name}</span>
                                </div>
                            </td>
                            {viewHeaders.map((header, colIndex) => {
                                const isMonthlyView = viewMode === 'M'
                                const cellValue = isMonthlyView
                                    ? (indexation.array[header.index] ?? 0)
                                    : getAggregatedValueForArray(indexation.array, header.indices, 'stock')
                                return (
                                    <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[36px] p-0">
                                        <DisplayCell value={cellValue} category="indexation" isTimeline={false} />
                                    </td>
                                )
                            })}
                        </tr>
                    ))}
                </>
            )}

            {/* Inputs Section Header */}
            {inputGlassGroups.filter(group => inputGlass.some(input => input.groupId === group.id)).length > 0 && (
                <tr className="bg-slate-200 border-b border-slate-300">
                    <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-300 px-4 py-2">
                        <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">Inputs</span>
                    </td>
                    {viewHeaders.map((_, colIndex) => (
                        <td key={colIndex} className="min-w-[90px] h-[36px] bg-slate-200"></td>
                    ))}
                </tr>
            )}

            {/* InputGlass Groups - Group Level with Sub-items */}
            {(() => {
                // Track mode indices to build correct references
                const modeIndices = { values: 0, series: 0, constant: 0, timing: 0 }
                const activeGroups = inputGlassGroups.filter(group => inputGlass.some(input => input.groupId === group.id))

                return activeGroups.map((group) => {
                    const groupInputs = inputGlass.filter(input => input.groupId === group.id)

                    // Determine group mode/type - check groupType first, then fall back to input mode
                    let normalizedMode
                    if (group.groupType === 'timing') {
                        normalizedMode = 'timing'
                    } else {
                        const groupMode = groupInputs[0]?.mode || 'values'
                        normalizedMode = groupMode === 'constants' ? 'constant' : groupMode
                    }

                    modeIndices[normalizedMode]++
                    const modePrefix = normalizedMode === 'timing' ? 'T' :
                                      normalizedMode === 'series' ? 'S' :
                                      normalizedMode === 'constant' ? 'C' : 'V'
                    const groupRef = `${modePrefix}${modeIndices[normalizedMode]}`

                    // Get type from referenceTypeMap (defaults to 'flow' if not found)
                    const groupType = referenceTypeMap?.[groupRef] || 'flow'

                    // Generate periods at viewMode frequency for value lookup
                    // Resolve linked key period dates if applicable
                    const groupPeriods = generatePeriods(group, config, keyPeriods)
                    const viewModeMonthsPerPeriod = getMonthsPerPeriod(viewMode)
                    const viewModePeriods = []
                    let startYear, startMonth, totalMonths

                    if (keyPeriods && group.linkedKeyPeriodId) {
                        const linkedKeyPeriod = keyPeriods.find(kp =>
                            String(kp.id) === String(group.linkedKeyPeriodId)
                        )
                        if (linkedKeyPeriod) {
                            startYear = linkedKeyPeriod.startYear ?? config.startYear ?? 2024
                            startMonth = linkedKeyPeriod.startMonth ?? config.startMonth ?? 1
                            totalMonths = linkedKeyPeriod.periods || 12
                        } else {
                            startYear = group.startYear ?? config.startYear ?? 2024
                            startMonth = group.startMonth ?? config.startMonth ?? 1
                            totalMonths = group.periods || 12
                        }
                    } else {
                        startYear = group.startYear ?? config.startYear ?? 2024
                        startMonth = group.startMonth ?? config.startMonth ?? 1
                        if (group.startDate && !group.startYear) {
                            const [y, m] = group.startDate.split('-').map(Number)
                            startYear = y
                            startMonth = m
                        }
                        totalMonths = group.periods || 12
                    }

                    // For FY view, align periods to fiscal year boundaries
                    const fyStartMonth = config?.fyStartMonth || 7

                    if (viewMode === 'FY') {
                        // Find the fiscal year that contains the start date
                        let fyStartYear = startMonth < fyStartMonth ? startYear - 1 : startYear
                        let fyStart = fyStartMonth

                        // Calculate how many fiscal years we need
                        const endYear = startYear + Math.floor((startMonth - 1 + totalMonths) / 12)
                        const endMonth = ((startMonth - 1 + totalMonths) % 12) + 1
                        const fyEndYear = endMonth < fyStartMonth ? endYear - 1 : endYear

                        const numFYPeriods = fyEndYear - fyStartYear + 1

                        for (let i = 0; i < numFYPeriods; i++) {
                            viewModePeriods.push({
                                year: fyStartYear + i,
                                month: fyStart,
                                index: i,
                                fyEndYear: fyStartYear + i + 1
                            })
                        }
                    } else {
                        // Standard period generation for M, Q, Y
                        const numViewPeriods = Math.ceil(totalMonths / viewModeMonthsPerPeriod)
                        let curYear = startYear
                        let curMonth = startMonth
                        for (let i = 0; i < numViewPeriods; i++) {
                            viewModePeriods.push({ year: curYear, month: curMonth, index: i })
                            curMonth += viewModeMonthsPerPeriod
                            while (curMonth > 12) {
                                curMonth -= 12
                                curYear += 1
                            }
                        }
                    }

                    // Build map from viewHeader index to viewMode period index
                    const periodMap = new Map()
                    viewModePeriods.forEach((vp, idx) => {
                        viewHeaders.forEach((vh, vhIdx) => {
                            const timelineIdx = vh.index
                            const year = timeline.year[timelineIdx]
                            const month = timeline.month[timelineIdx]
                            if (vp.year === year && vp.month === month) {
                                periodMap.set(vhIdx, idx)
                            }
                        })
                    })

                    // Get values for each input using getValuesArray at viewMode frequency
                    const inputValuesArrays = groupInputs.map(input =>
                        getValuesArray(input, viewModePeriods, viewMode, group, config)
                    )

                    // Calculate group subtotal at viewMode frequency
                    const subtotalByPeriod = new Array(viewModePeriods.length).fill(0)
                    inputValuesArrays.forEach(arr => {
                        arr.forEach((val, i) => {
                            subtotalByPeriod[i] += val || 0
                        })
                    })

                    return (
                        <React.Fragment key={group.id}>
                            {/* Group Total Row */}
                            <tr className="hover:bg-slate-50 transition-colors border-b border-slate-200 bg-slate-50">
                                <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-2">
                                    <div className="flex items-center gap-2">
                                        <span className={`text-xs px-1.5 py-0.5 rounded font-medium ${
                                            normalizedMode === 'timing' ? 'text-teal-600 bg-teal-100' :
                                            normalizedMode === 'series' ? 'text-green-600 bg-green-100' :
                                            normalizedMode === 'constant' ? 'text-blue-600 bg-blue-100' :
                                            'text-purple-600 bg-purple-100'
                                        }`}>
                                            {groupRef}
                                        </span>
                                        <span className="text-sm font-semibold text-slate-900">{group.name}</span>
                                        <span className="text-xs text-slate-400">({groupInputs.length})</span>
                                    </div>
                                </td>
                                {viewHeaders.map((header, colIndex) => {
                                    // Use the mapped period index to get value at viewMode frequency
                                    const periodIdx = periodMap.get(colIndex)
                                    const cellValue = periodIdx !== undefined ? subtotalByPeriod[periodIdx] : 0
                                    return (
                                        <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[36px] p-0 bg-slate-50">
                                            <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                        </td>
                                    )
                                })}
                            </tr>
                            {/* Individual Input Rows */}
                            {groupInputs.map((input, inputIdx) => {
                                const inputRef = `${groupRef}.${inputIdx + 1}`
                                // Get values from our pre-computed arrays
                                const inputValues = inputValuesArrays[inputIdx] || []
                                return (
                                    <tr key={input.id} className="hover:bg-slate-50 transition-colors border-b border-slate-100">
                                        <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-1.5 pl-8">
                                            <div className="flex items-center gap-2">
                                                <span className={`text-xs px-1.5 py-0.5 rounded ${
                                                    normalizedMode === 'timing' ? 'text-teal-500 bg-teal-50' :
                                                    normalizedMode === 'series' ? 'text-green-500 bg-green-50' :
                                                    normalizedMode === 'constant' ? 'text-blue-500 bg-blue-50' :
                                                    'text-purple-500 bg-purple-50'
                                                }`}>
                                                    {inputRef}
                                                </span>
                                                <span className="text-sm text-slate-700">{input.name}</span>
                                            </div>
                                        </td>
                                        {viewHeaders.map((header, colIndex) => {
                                            // Use the mapped period index to get value at viewMode frequency
                                            const periodIdx = periodMap.get(colIndex)
                                            const cellValue = periodIdx !== undefined ? inputValues[periodIdx] : 0
                                            return (
                                                <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[32px] p-0">
                                                    <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                                </td>
                                            )
                                        })}
                                    </tr>
                                )
                            })}
                        </React.Fragment>
                    )
                })
            })()}

            {/* Lookups Section */}
            {(() => {
                const lookupGroups = inputGlassGroups.filter(g => g.entryMode === 'lookup' || g.entryMode === 'lookup2')
                if (lookupGroups.length === 0) return null

                // Helper to group inputs by subgroup
                const groupInputsBySubgroup = (groupInputs, group) => {
                    const subgroups = group.subgroups || []
                    const result = []
                    const rootInputs = groupInputs.filter(inp => !inp.subgroupId)
                    if (rootInputs.length > 0 || subgroups.length === 0) {
                        result.push({ id: null, name: null, inputs: rootInputs })
                    }
                    subgroups.forEach(sg => {
                        const sgInputs = groupInputs.filter(inp => inp.subgroupId === sg.id)
                        result.push({ id: sg.id, name: sg.name, inputs: sgInputs })
                    })
                    return result
                }

                return (
                    <>
                        <tr className="bg-slate-200 border-b border-slate-300">
                            <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-300 px-4 py-2">
                                <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">Lookups</span>
                            </td>
                            {viewHeaders.map((_, colIndex) => (
                                <td key={colIndex} className="min-w-[90px] h-[36px] bg-slate-200"></td>
                            ))}
                        </tr>
                        {lookupGroups.map((group, idx) => {
                            const groupInputs = inputGlass.filter(input => input.groupId === group.id)
                            const lookupRef = `L${idx + 1}`

                            if (groupInputs.length === 0) return null

                            // Group by subgroups to get correct selections
                            const subgroupedInputs = groupInputsBySubgroup(groupInputs, group)
                            const selectedIndices = group.selectedIndices || {}

                            return (
                                <React.Fragment key={group.id}>
                                    {/* Group Header Row */}
                                    <tr className="bg-lime-50 border-b border-lime-200">
                                        <td className="frozen-col w-[300px] min-w-[300px] border-r border-lime-200 px-4 py-2 bg-lime-50">
                                            <div className="flex items-center gap-2">
                                                <span className="text-xs text-lime-600 bg-lime-100 px-1.5 py-0.5 rounded font-medium">{lookupRef}</span>
                                                <span className="text-sm font-semibold text-slate-900">{group.name}</span>
                                                <span className="text-xs text-slate-400">({groupInputs.length} options)</span>
                                            </div>
                                        </td>
                                        {viewHeaders.map((_, colIndex) => (
                                            <td key={colIndex} className="min-w-[90px] h-[36px] bg-lime-50"></td>
                                        ))}
                                    </tr>
                                    {/* Selected values for each subgroup */}
                                    {(() => {
                                        // Generate periods at viewMode frequency for this lookup group
                                        // Resolve linked key period dates if applicable
                                        const lookupViewModeMonths = getMonthsPerPeriod(viewMode)
                                        const lookupViewModePeriods = []
                                        let lookupStartYear, lookupStartMonth, lookupTotalMonths

                                        if (keyPeriods && group.linkedKeyPeriodId) {
                                            const linkedKeyPeriod = keyPeriods.find(kp =>
                                                String(kp.id) === String(group.linkedKeyPeriodId)
                                            )
                                            if (linkedKeyPeriod) {
                                                lookupStartYear = linkedKeyPeriod.startYear ?? config.startYear ?? 2024
                                                lookupStartMonth = linkedKeyPeriod.startMonth ?? config.startMonth ?? 1
                                                lookupTotalMonths = linkedKeyPeriod.periods || 12
                                            } else {
                                                lookupStartYear = group.startYear ?? config.startYear ?? 2024
                                                lookupStartMonth = group.startMonth ?? config.startMonth ?? 1
                                                lookupTotalMonths = group.periods || 12
                                            }
                                        } else {
                                            lookupStartYear = group.startYear ?? config.startYear ?? 2024
                                            lookupStartMonth = group.startMonth ?? config.startMonth ?? 1
                                            if (group.startDate && !group.startYear) {
                                                const [y, m] = group.startDate.split('-').map(Number)
                                                lookupStartYear = y
                                                lookupStartMonth = m
                                            }
                                            lookupTotalMonths = group.periods || 12
                                        }

                                        // For FY view, align periods to fiscal year boundaries
                                        const fyStartMonth = config?.fyStartMonth || 7

                                        if (viewMode === 'FY') {
                                            // Find the fiscal year that contains the start date
                                            let fyStartYear = lookupStartMonth < fyStartMonth ? lookupStartYear - 1 : lookupStartYear
                                            let fyStart = fyStartMonth

                                            // Calculate how many fiscal years we need
                                            const endYear = lookupStartYear + Math.floor((lookupStartMonth - 1 + lookupTotalMonths) / 12)
                                            const endMonth = ((lookupStartMonth - 1 + lookupTotalMonths) % 12) + 1
                                            const fyEndYear = endMonth < fyStartMonth ? endYear - 1 : endYear

                                            const numFYPeriods = fyEndYear - fyStartYear + 1

                                            for (let i = 0; i < numFYPeriods; i++) {
                                                lookupViewModePeriods.push({
                                                    year: fyStartYear + i,
                                                    month: fyStart,
                                                    index: i,
                                                    fyEndYear: fyStartYear + i + 1
                                                })
                                            }
                                        } else {
                                            // Standard period generation for M, Q, Y
                                            const numLookupPeriods = Math.ceil(lookupTotalMonths / lookupViewModeMonths)
                                            let curYear = lookupStartYear
                                            let curMonth = lookupStartMonth
                                            for (let i = 0; i < numLookupPeriods; i++) {
                                                lookupViewModePeriods.push({ year: curYear, month: curMonth, index: i })
                                                curMonth += lookupViewModeMonths
                                                while (curMonth > 12) {
                                                    curMonth -= 12
                                                    curYear += 1
                                                }
                                            }
                                        }

                                        // Build map from viewHeader index to viewMode period index
                                        const lookupPeriodMap = new Map()
                                        lookupViewModePeriods.forEach((vp, idx) => {
                                            viewHeaders.forEach((vh, vhIdx) => {
                                                const timelineIdx = vh.index
                                                const year = timeline.year[timelineIdx]
                                                const month = timeline.month[timelineIdx]
                                                if (vp.year === year && vp.month === month) {
                                                    lookupPeriodMap.set(vhIdx, idx)
                                                }
                                            })
                                        })

                                        return subgroupedInputs.map((sg, sgIdx) => {
                                            if (sg.inputs.length === 0) return null

                                            const key = sg.id ?? 'root'
                                            const selectedIdx = selectedIndices[key] ?? 0
                                            const selectedInput = sg.inputs[selectedIdx] || sg.inputs[0]

                                            if (!selectedInput) return null

                                            // Use getValuesArray at viewMode frequency
                                            const inputValues = getValuesArray(selectedInput, lookupViewModePeriods, viewMode, group, config)
                                            const subgroupRef = `${lookupRef}.${sgIdx + 1}`

                                            return (
                                                <tr key={sg.id ?? 'root'} className="bg-amber-50 border-b border-amber-200">
                                                    <td className="frozen-col w-[300px] min-w-[300px] border-r border-amber-200 px-4 py-2 pl-6 bg-amber-50">
                                                        <div className="flex items-center gap-2">
                                                            <span className="text-xs text-amber-600 bg-amber-100 px-1.5 py-0.5 rounded font-medium">
                                                                {subgroupRef}
                                                            </span>
                                                            {sg.name && (
                                                                <span className="text-xs text-slate-500">{sg.name}:</span>
                                                            )}
                                                            <span className="text-sm font-medium text-amber-800">{selectedInput.name}</span>
                                                            <span className="text-[10px] text-amber-500">‚óè selected</span>
                                                        </div>
                                                    </td>
                                                    {viewHeaders.map((header, colIndex) => {
                                                        // Use the mapped period index to get value at viewMode frequency
                                                        const periodIdx = lookupPeriodMap.get(colIndex)
                                                        const cellValue = periodIdx !== undefined ? inputValues[periodIdx] : 0
                                                        return (
                                                            <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[36px] p-0 bg-amber-50">
                                                                <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                                            </td>
                                                        )
                                                    })}
                                                </tr>
                                            )
                                        })
                                    })()}
                                </React.Fragment>
                            )
                        })}
                    </>
                )
            })()}
        </>
    )
}

function ModulesSubTab({ modules, viewHeaders, viewMode }) {
    if (!modules || modules.length === 0) {
        return (
            <tr>
                <td colSpan={viewHeaders.length + 1} className="text-center py-12 text-slate-400">
                    No modules added yet
                </td>
            </tr>
        )
    }

    return (
        <>
            {modules.map((module, moduleIdx) => (
                <React.Fragment key={module.id}>
                    {/* Module Header Row */}
                    <tr className="hover:bg-slate-50 transition-colors border-b border-slate-200 bg-slate-50">
                        <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-2">
                            <div className="flex items-center gap-2">
                                <span className="text-xs text-orange-600 bg-orange-100 px-1.5 py-0.5 rounded font-medium">M{moduleIdx + 1}</span>
                                <span className="text-sm font-semibold text-slate-900">{module.name}</span>
                                <span className="text-xs text-slate-400">({module.outputs?.length || 0} outputs)</span>
                            </div>
                        </td>
                        {viewHeaders.map((header, colIndex) => (
                            <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[36px] p-0 bg-slate-50">
                                <DisplayCell value={null} category="value" isTimeline={false} />
                            </td>
                        ))}
                    </tr>
                    {/* Module Output Rows */}
                    {module.outputs && module.outputs.map((output, outputIdx) => {
                        // TODO: Get actual calculated output array when available
                        const outputArray = []
                        return (
                            <tr key={output} className="hover:bg-slate-50 transition-colors border-b border-slate-100">
                                <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-1.5 pl-8">
                                    <div className="flex items-center gap-2">
                                        <span className="text-xs text-orange-500 bg-orange-50 px-1.5 py-0.5 rounded">
                                            M{moduleIdx + 1}.{outputIdx + 1}
                                        </span>
                                        <span className="text-sm text-slate-700">{output.replace(/_/g, ' ')}</span>
                                    </div>
                                </td>
                                {viewHeaders.map((header, colIndex) => {
                                    const isMonthlyView = viewMode === 'M'
                                    const cellValue = isMonthlyView
                                        ? (outputArray[header.index] ?? 0)
                                        : getAggregatedValueForArray(outputArray, header.indices, 'flow')
                                    return (
                                        <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[32px] p-0">
                                            <DisplayCell value={cellValue} category="module" isTimeline={false} />
                                        </td>
                                    )
                                })}
                            </tr>
                        )
                    })}
                </React.Fragment>
            ))}
        </>
    )
}

function ResultsSubTab({ calculations, calculationResults, calculationTypes, viewHeaders, viewMode }) {
    if (!calculations || calculations.length === 0) {
        return (
            <tr>
                <td colSpan={viewHeaders.length + 1} className="text-center py-12 text-slate-400">
                    No calculations yet
                </td>
            </tr>
        )
    }

    return (
        <>
            {calculations.map((calc, calcIndex) => {
                const calcRef = `R${calcIndex + 1}`
                const resultArray = calculationResults[calcRef] || []
                // Get type from calculationTypes (defaults to 'flow' if not found)
                const calcType = calculationTypes?.[calcRef] || 'flow'
                return (
                    <tr key={calc.id} className="hover:bg-slate-50 transition-colors border-b border-slate-200">
                        <td className="frozen-col w-[300px] min-w-[300px] border-r border-slate-200 px-4 py-2">
                            <div className="flex items-center gap-2">
                                <span className="text-xs text-rose-600 bg-rose-100 px-1.5 py-0.5 rounded font-medium">{calcRef}</span>
                                <span className="text-sm font-medium text-slate-900">{calc.name}</span>
                                {/* Show type indicator */}
                                <span className={`text-[10px] px-1 py-0.5 rounded ${
                                    calcType === 'flow'
                                        ? 'text-emerald-600 bg-emerald-50'
                                        : 'text-slate-500 bg-slate-100'
                                }`}>
                                    {calcType === 'flow' ? 'flow' : 'stock'}
                                </span>
                            </div>
                        </td>
                        {viewHeaders.map((header, colIndex) => {
                            const isMonthlyView = viewMode === 'M'
                            const cellValue = isMonthlyView
                                ? (resultArray[header.index] ?? 0)
                                : getAggregatedValueForArray(resultArray, header.indices, calcType)
                            return (
                                <td key={colIndex} className="spreadsheet-cell min-w-[90px] h-[36px] p-0">
                                    <DisplayCell value={cellValue} category="result" isTimeline={false} />
                                </td>
                            )
                        })}
                    </tr>
                )
            })}
        </>
    )
}
