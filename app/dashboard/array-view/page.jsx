'use client'

import React, { useCallback } from 'react'
import { DisplayCell } from '@/components/inputs/Cells'
import { getAggregatedValueForArray } from '../../../utils/valueAggregation'
import { groupInputsBySubgroup, generatePeriods } from '@/components/inputs/utils/inputHelpers'
import { useDashboard } from '../context/DashboardContext'
import { Download } from 'lucide-react'

export default function ArrayViewPage() {
    const {
        viewMode,
        appState,
        setters,
        derived,
        uiState
    } = useDashboard()

    const {
        inputGlass,
        inputGlassGroups,
        modules,
        calculations,
        calculationsTabs,
        calculationsGroups,
        config,
        keyPeriods
    } = appState

    const { setArrayViewSubTab } = setters

    const {
        timeline,
        viewHeaders,
        inputGlassArrays,
        autoGeneratedFlags,
        autoGeneratedIndexations,
        calculationResults,
        referenceTypeMap,
        calculationTypes
    } = derived

    const { arrayViewSubTab } = uiState

    // Build calcIndexMap for stable R references using ID-based resolution
    // Maps calc.id to itself - R references resolve by ID, not position
    const calcIndexMap = new Map()
    ;(calculations || []).forEach(calc => {
        calcIndexMap.set(calc.id, calc.id)
    })

    // Build yearly headers for debug export
    const buildYearlyHeaders = useCallback(() => {
        const years = []
        const yearMap = new Map()

        for (let i = 0; i < timeline.periods; i++) {
            const year = timeline.year[i]
            if (!yearMap.has(year)) {
                yearMap.set(year, [])
            }
            yearMap.get(year).push(i)
        }

        yearMap.forEach((indices, year) => {
            years.push({ year, indices })
        })

        return years
    }, [timeline])

    // Export debug data function - supports both yearly and monthly
    const handleExportDebug = useCallback(async (exportMonthly = false) => {
        const yearlyHeaders = buildYearlyHeaders()
        const debugData = {
            exportedAt: new Date().toISOString(),
            granularity: exportMonthly ? 'monthly' : 'yearly',
            timeline: {
                startYear: config.startYear,
                startMonth: config.startMonth,
                endYear: config.endYear,
                endMonth: config.endMonth,
                periods: timeline.periods
            },
            years: yearlyHeaders.map(h => h.year),
            inputs: {},
            calculations: {}
        }

        // Build mode indices for reference names
        const modeIndices = { values: 0, series: 0, constant: 0, timing: 0 }

        // Export Flags (F1, F2, ...)
        Object.values(autoGeneratedFlags).forEach((flag, idx) => {
            const ref = `F${idx + 1}`
            debugData.inputs[ref] = {
                name: flag.name,
                type: 'flag',
                yearly: exportMonthly
                    ? [...flag.array]
                    : yearlyHeaders.map(h => getAggregatedValueForArray(flag.array, h.indices, 'flow', 'flag'))
            }
        })

        // Export Indexations (I1, I2, ...)
        Object.values(autoGeneratedIndexations).forEach((indexation, idx) => {
            const ref = `I${idx + 1}`
            debugData.inputs[ref] = {
                name: indexation.name,
                type: 'indexation',
                yearly: exportMonthly
                    ? [...indexation.array]
                    : yearlyHeaders.map(h => getAggregatedValueForArray(indexation.array, h.indices, 'stock'))
            }
        })

        // Export InputGlass groups (V1, S1, C1, T1, etc.)
        const activeGroups = inputGlassGroups.filter(group =>
            inputGlass.some(input => input.groupId === group.id)
        )

        activeGroups.forEach(group => {
            const groupInputs = inputGlass.filter(input => input.groupId === group.id)

            // Determine group mode
            let normalizedMode
            if (group.groupType === 'timing') {
                normalizedMode = 'timing'
            } else {
                const groupMode = groupInputs[0]?.mode || 'values'
                normalizedMode = groupMode === 'constants' ? 'constant' : groupMode
            }

            modeIndices[normalizedMode]++
            const modePrefix = normalizedMode === 'timing' ? 'T' :
                              normalizedMode === 'series' ? 'S' :
                              normalizedMode === 'constant' ? 'C' : 'V'
            const groupRef = `${modePrefix}${modeIndices[normalizedMode]}`
            const groupType = referenceTypeMap?.[groupRef] || 'flow'

            // Group total
            const groupTotals = exportMonthly
                ? (() => {
                    const totals = new Array(timeline.periods).fill(0)
                    groupInputs.forEach(input => {
                        const arr = inputGlassArrays[`inputtype3_${input.id}`] || []
                        for (let i = 0; i < timeline.periods; i++) {
                            totals[i] += arr[i] || 0
                        }
                    })
                    return totals
                })()
                : yearlyHeaders.map(h => {
                    return groupInputs.reduce((sum, input) => {
                        const arr = inputGlassArrays[`inputtype3_${input.id}`] || []
                        return sum + getAggregatedValueForArray(arr, h.indices, groupType)
                    }, 0)
                })

            debugData.inputs[groupRef] = {
                name: group.name,
                type: groupType,
                yearly: groupTotals
            }

            // Individual inputs - use each input's own type from referenceTypeMap
            groupInputs.forEach((input, idx) => {
                const inputRef = `${groupRef}.${idx + 1}`
                const inputType = referenceTypeMap?.[inputRef] || groupType
                const arr = inputGlassArrays[`inputtype3_${input.id}`] || []
                debugData.inputs[inputRef] = {
                    name: input.name,
                    type: inputType,
                    yearly: exportMonthly
                        ? [...arr]
                        : yearlyHeaders.map(h => getAggregatedValueForArray(arr, h.indices, inputType))
                }
            })
        })

        // Export Lookups (L1, L2, ...)
        const lookupGroups = inputGlassGroups.filter(g =>
            g.entryMode === 'lookup' || g.entryMode === 'lookup2'
        )

        lookupGroups.forEach((group, idx) => {
            const groupInputs = inputGlass.filter(input => input.groupId === group.id)
            const lookupRef = `L${idx + 1}`
            const lookupType = referenceTypeMap?.[lookupRef] || 'stock'

            if (groupInputs.length === 0) return

            const subgroupedInputs = groupInputsBySubgroup(groupInputs, group)
            const selectedIndices = group.selectedIndices || {}

            subgroupedInputs.forEach((sg, sgIdx) => {
                if (sg.inputs.length === 0) return

                const key = sg.id ?? 'root'
                const selectedIdx = selectedIndices[key] ?? 0
                const selectedInput = sg.inputs[selectedIdx] || sg.inputs[0]

                if (!selectedInput) return

                const subgroupRef = `${lookupRef}.${sgIdx + 1}`
                const arr = inputGlassArrays[`inputtype3_${selectedInput.id}`] || []

                debugData.inputs[subgroupRef] = {
                    name: `${sg.name ? sg.name + ': ' : ''}${selectedInput.name}`,
                    type: lookupType,
                    yearly: exportMonthly
                        ? [...arr]
                        : yearlyHeaders.map(h => getAggregatedValueForArray(arr, h.indices, lookupType))
                }
            })
        })

        // Export Calculations (R1, R2, ...)
        ;(calculations || []).forEach(calc => {
            const calcRef = `R${calcIndexMap.get(calc.id)}`
            const resultArray = calculationResults[calcRef] || []
            const calcType = calculationTypes?.[calcRef] || 'flow'

            debugData.calculations[calcRef] = {
                name: calc.name,
                formula: calc.formula,
                type: calcType,
                yearly: exportMonthly
                    ? [...resultArray]
                    : yearlyHeaders.map(h => getAggregatedValueForArray(resultArray, h.indices, calcType))
            }
        })

        // Send to API (compact=true by default for token optimization)
        const suffix = exportMonthly ? '&monthly=true' : ''
        try {
            const response = await fetch(`/api/debug-export?compact=true${suffix}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(debugData)
            })
            const result = await response.json()
            if (result.success) {
                const granLabel = exportMonthly ? 'monthly' : 'yearly'
                alert(`Debug data exported (${granLabel}): ${result.filename} (${result.sizeKB} KB${result.compact ? ', compact' : ''})`)
            } else {
                alert(`Export failed: ${result.error}`)
            }
        } catch (error) {
            console.error('Export error:', error)
            alert(`Export failed: ${error.message}`)
        }
    }, [
        buildYearlyHeaders, config, timeline, autoGeneratedFlags, autoGeneratedIndexations,
        inputGlass, inputGlassGroups, inputGlassArrays, referenceTypeMap,
        calculations, calculationResults, calculationTypes, calcIndexMap
    ])

    return (
        <main className="max-w-[1800px] mx-auto px-6 py-6">
            <div className="bg-white backdrop-blur border border-slate-200 rounded-xl overflow-hidden shadow-lg">
                {/* Array View Header with Sub-tabs */}
                <div className="bg-slate-50 border-b border-slate-200 px-6 py-4">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-4">
                            <h2 className="text-lg font-semibold text-slate-900">Array View</h2>
                            <span className={`text-xs font-semibold px-2 py-0.5 rounded ${
                                viewMode === 'M' ? 'bg-indigo-100 text-indigo-700' :
                                viewMode === 'Q' ? 'bg-emerald-100 text-emerald-700' :
                                viewMode === 'Y' ? 'bg-amber-100 text-amber-700' :
                                'bg-purple-100 text-purple-700'
                            }`}>
                                {viewMode === 'M' ? 'Monthly' : viewMode === 'Q' ? 'Quarterly' : viewMode === 'Y' ? 'Yearly' : 'Financial Year'}
                            </span>
                            {/* Sub-tabs */}
                            <div className="flex bg-slate-200 p-1 rounded-lg">
                                {[
                                    { id: 'inputs', label: 'Inputs' },
                                    { id: 'modules', label: 'Modules' },
                                    { id: 'results', label: 'Results' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setArrayViewSubTab(tab.id)}
                                        className={`px-3 py-1 rounded text-sm font-medium transition-all ${
                                            arrayViewSubTab === tab.id
                                                ? 'bg-white text-slate-900 shadow-sm'
                                                : 'text-slate-600 hover:text-slate-900'
                                        }`}
                                    >
                                        {tab.label}
                                    </button>
                                ))}
                            </div>
                        </div>
                        {/* Export Debug Buttons */}
                        <div className="flex items-center gap-1">
                            <button
                                onClick={() => handleExportDebug(false)}
                                className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-slate-600 hover:text-slate-900 bg-slate-100 hover:bg-slate-200 rounded-l-lg transition-colors"
                                title="Export yearly aggregated debug data"
                            >
                                <Download className="w-4 h-4" />
                                Yearly
                            </button>
                            <button
                                onClick={() => handleExportDebug(true)}
                                className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-indigo-600 hover:text-indigo-900 bg-indigo-100 hover:bg-indigo-200 rounded-r-lg transition-colors"
                                title="Export monthly granular debug data"
                            >
                                Monthly
                            </button>
                        </div>
                    </div>
                </div>

                {/* Array View Content */}
                <div className="overflow-x-auto overflow-y-auto scrollbar-thin" style={{ maxHeight: 'calc(100vh - 300px)' }}>
                    <table className="glass-grid w-full border-collapse" style={{ minWidth: viewMode === 'M' ? `${200 + viewHeaders.length * 55}px` : '100%' }}>
                        <thead className="sticky top-0 z-30">
                            <tr className="bg-slate-100">
                                <th className="frozen-col w-[180px] min-w-[180px] px-2 py-1.5 text-left border-b border-r border-slate-600 bg-slate-100">
                                    <span className="text-[10px] font-semibold text-slate-400 uppercase tracking-wider">
                                        {arrayViewSubTab === 'inputs' ? 'Input Groups' : arrayViewSubTab === 'modules' ? 'Modules' : 'Calculations'}
                                    </span>
                                </th>
                                {viewHeaders.map((header, i) => (
                                    <th key={i} className="px-1 py-1.5 text-center border-b border-slate-600 min-w-[55px] bg-slate-100">
                                        <span className="text-[10px] font-semibold text-slate-400">{header.label}</span>
                                    </th>
                                ))}
                            </tr>
                        </thead>
                        <tbody>
                            {/* Inputs Sub-tab */}
                            {arrayViewSubTab === 'inputs' && (
                                <InputsSubTab
                                    inputGlass={inputGlass}
                                    inputGlassGroups={inputGlassGroups}
                                    inputGlassArrays={inputGlassArrays}
                                    autoGeneratedFlags={autoGeneratedFlags}
                                    autoGeneratedIndexations={autoGeneratedIndexations}
                                    timeline={timeline}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                    referenceTypeMap={referenceTypeMap}
                                    config={config}
                                    keyPeriods={keyPeriods}
                                />
                            )}

                            {/* Modules Sub-tab */}
                            {arrayViewSubTab === 'modules' && (
                                <ModulesSubTab
                                    modules={modules}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                />
                            )}

                            {/* Results Sub-tab */}
                            {arrayViewSubTab === 'results' && (
                                <ResultsSubTab
                                    calculations={calculations}
                                    calculationsTabs={calculationsTabs}
                                    calculationsGroups={calculationsGroups}
                                    calculationResults={calculationResults}
                                    calculationTypes={calculationTypes}
                                    viewHeaders={viewHeaders}
                                    viewMode={viewMode}
                                    calcIndexMap={calcIndexMap}
                                />
                            )}
                        </tbody>
                    </table>
                </div>
            </div>
        </main>
    )
}

function InputsSubTab({
    inputGlass,
    inputGlassGroups,
    inputGlassArrays,
    autoGeneratedFlags,
    autoGeneratedIndexations,
    timeline,
    viewHeaders,
    viewMode,
    referenceTypeMap,
    config,
    keyPeriods = []
}) {
    return (
        <>
            {/* Timing Section */}
            {(Object.keys(autoGeneratedFlags).length > 0 || Object.keys(autoGeneratedIndexations).length > 0) && (
                <>
                    {/* Timing Section Header */}
                    <tr className="bg-slate-200 border-b border-slate-300">
                        <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-300 px-2 py-1">
                            <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">Timing</span>
                        </td>
                        {viewHeaders.map((_, colIndex) => (
                            <td key={colIndex} className="min-w-[55px] h-[24px] bg-slate-200"></td>
                        ))}
                    </tr>

                    {/* Flags */}
                    {Object.values(autoGeneratedFlags).map((flag, idx) => (
                        <tr key={flag.id} className="hover:bg-slate-50 transition-colors border-b border-slate-200">
                            <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-200 px-2 py-1 pl-4">
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-amber-600 bg-amber-100 px-1 py-0 rounded font-medium">F{idx + 1}</span>
                                    <span className="text-[11px] font-medium text-slate-900">{flag.name}</span>
                                </div>
                            </td>
                            {viewHeaders.map((header, colIndex) => {
                                const isMonthlyView = viewMode === 'M'
                                const cellValue = isMonthlyView
                                    ? (flag.array[header.index] ?? 0)
                                    : getAggregatedValueForArray(flag.array, header.indices, 'flow', 'flag')
                                return (
                                    <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0">
                                        <DisplayCell value={cellValue} category="flag" isTimeline={false} />
                                    </td>
                                )
                            })}
                        </tr>
                    ))}

                    {/* Indexations */}
                    {Object.values(autoGeneratedIndexations).map((indexation, idx) => (
                        <tr key={indexation.id} className="hover:bg-slate-50 transition-colors border-b border-slate-200">
                            <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-200 px-2 py-1 pl-4">
                                <div className="flex items-center gap-2">
                                    <span className="text-xs text-cyan-600 bg-cyan-100 px-1 py-0 rounded font-medium">I{idx + 1}</span>
                                    <span className="text-[11px] font-medium text-slate-900">{indexation.name}</span>
                                </div>
                            </td>
                            {viewHeaders.map((header, colIndex) => {
                                const isMonthlyView = viewMode === 'M'
                                const cellValue = isMonthlyView
                                    ? (indexation.array[header.index] ?? 0)
                                    : getAggregatedValueForArray(indexation.array, header.indices, 'stock')
                                return (
                                    <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0">
                                        <DisplayCell value={cellValue} category="indexation" isTimeline={false} />
                                    </td>
                                )
                            })}
                        </tr>
                    ))}
                </>
            )}

            {/* Inputs Section Header */}
            {inputGlassGroups.filter(group => inputGlass.some(input => input.groupId === group.id)).length > 0 && (
                <tr className="bg-slate-200 border-b border-slate-300">
                    <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-300 px-2 py-1">
                        <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">Inputs</span>
                    </td>
                    {viewHeaders.map((_, colIndex) => (
                        <td key={colIndex} className="min-w-[55px] h-[24px] bg-slate-200"></td>
                    ))}
                </tr>
            )}

            {/* InputGlass Groups - Group Level with Sub-items */}
            {(() => {
                // Track mode indices to build correct references
                const modeIndices = { values: 0, series: 0, constant: 0, timing: 0 }
                const activeGroups = inputGlassGroups.filter(group => inputGlass.some(input => input.groupId === group.id))

                return activeGroups.map((group) => {
                    const groupInputs = inputGlass.filter(input => input.groupId === group.id)

                    // Determine group mode/type - check groupType first, then fall back to input mode
                    let normalizedMode
                    if (group.groupType === 'timing') {
                        normalizedMode = 'timing'
                    } else {
                        const groupMode = groupInputs[0]?.mode || 'values'
                        normalizedMode = groupMode === 'constants' ? 'constant' : groupMode
                    }

                    modeIndices[normalizedMode]++
                    const modePrefix = normalizedMode === 'timing' ? 'T' :
                                      normalizedMode === 'series' ? 'S' :
                                      normalizedMode === 'constant' ? 'C' : 'V'
                    const groupRef = `${modePrefix}${modeIndices[normalizedMode]}`

                    // Get type from referenceTypeMap (defaults to 'flow' if not found)
                    const groupType = referenceTypeMap?.[groupRef] || 'flow'
                    const isMonthlyView = viewMode === 'M'

                    // Get pre-computed monthly arrays from inputGlassArrays (already mapped to model timeline)
                    const inputMonthlyArrays = groupInputs.map(input =>
                        inputGlassArrays[`inputtype3_${input.id}`] || new Array(timeline.periods).fill(0)
                    )

                    return (
                        <React.Fragment key={group.id}>
                            {/* Group Total Row */}
                            <tr className="hover:bg-slate-50 transition-colors border-b border-slate-200 bg-slate-50">
                                <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-200 px-2 py-1">
                                    <div className="flex items-center gap-2">
                                        <span className={`text-xs px-1 py-0 rounded font-medium ${
                                            normalizedMode === 'timing' ? 'text-teal-600 bg-teal-100' :
                                            normalizedMode === 'series' ? 'text-green-600 bg-green-100' :
                                            normalizedMode === 'constant' ? 'text-blue-600 bg-blue-100' :
                                            'text-purple-600 bg-purple-100'
                                        }`}>
                                            {groupRef}
                                        </span>
                                        <span className="text-[11px] font-semibold text-slate-900">{group.name}</span>
                                        <span className="text-xs text-slate-400">({groupInputs.length})</span>
                                    </div>
                                </td>
                                {viewHeaders.map((header, colIndex) => {
                                    // Calculate group subtotal for this column
                                    let cellValue = 0
                                    inputMonthlyArrays.forEach(arr => {
                                        if (isMonthlyView) {
                                            cellValue += arr[header.index] ?? 0
                                        } else {
                                            cellValue += getAggregatedValueForArray(arr, header.indices, groupType)
                                        }
                                    })
                                    return (
                                        <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0 bg-slate-50">
                                            <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                        </td>
                                    )
                                })}
                            </tr>
                            {/* Individual Input Rows */}
                            {groupInputs.map((input, inputIdx) => {
                                const inputRef = `${groupRef}.${inputIdx + 1}`
                                // Get pre-computed monthly array for this input
                                const inputMonthlyArray = inputMonthlyArrays[inputIdx] || []
                                return (
                                    <tr key={input.id} className="hover:bg-slate-50 transition-colors border-b border-slate-100">
                                        <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-200 px-2 py-0.5 pl-5">
                                            <div className="flex items-center gap-2">
                                                <span className={`text-xs px-1 py-0 rounded ${
                                                    normalizedMode === 'timing' ? 'text-teal-500 bg-teal-50' :
                                                    normalizedMode === 'series' ? 'text-green-500 bg-green-50' :
                                                    normalizedMode === 'constant' ? 'text-blue-500 bg-blue-50' :
                                                    'text-purple-500 bg-purple-50'
                                                }`}>
                                                    {inputRef}
                                                </span>
                                                <span className="text-[11px] text-slate-700">{input.name}</span>
                                            </div>
                                        </td>
                                        {viewHeaders.map((header, colIndex) => {
                                            // Use inputGlassArrays directly with aggregation for non-monthly views
                                            const cellValue = isMonthlyView
                                                ? (inputMonthlyArray[header.index] ?? 0)
                                                : getAggregatedValueForArray(inputMonthlyArray, header.indices, groupType)
                                            return (
                                                <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[22px] p-0">
                                                    <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                                </td>
                                            )
                                        })}
                                    </tr>
                                )
                            })}
                        </React.Fragment>
                    )
                })
            })()}

            {/* Lookups Section */}
            {(() => {
                const lookupGroups = inputGlassGroups.filter(g => g.entryMode === 'lookup' || g.entryMode === 'lookup2')
                if (lookupGroups.length === 0) return null

                const isMonthlyView = viewMode === 'M'

                return (
                    <>
                        <tr className="bg-slate-200 border-b border-slate-300">
                            <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-300 px-2 py-1">
                                <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">Lookups</span>
                            </td>
                            {viewHeaders.map((_, colIndex) => (
                                <td key={colIndex} className="min-w-[55px] h-[24px] bg-slate-200"></td>
                            ))}
                        </tr>
                        {lookupGroups.map((group, idx) => {
                            const groupInputs = inputGlass.filter(input => input.groupId === group.id)
                            const lookupRef = `L${idx + 1}`

                            if (groupInputs.length === 0) return null

                            // Group by subgroups to get correct selections
                            const subgroupedInputs = groupInputsBySubgroup(groupInputs, group)
                            const selectedIndices = group.selectedIndices || {}

                            // Lookups are stock values by default
                            const lookupType = referenceTypeMap?.[lookupRef] || 'stock'

                            return (
                                <React.Fragment key={group.id}>
                                    {/* Group Header Row */}
                                    <tr className="bg-lime-50 border-b border-lime-200">
                                        <td className="frozen-col w-[180px] min-w-[180px] border-r border-lime-200 px-2 py-1 bg-lime-50">
                                            <div className="flex items-center gap-2">
                                                <span className="text-xs text-lime-600 bg-lime-100 px-1 py-0 rounded font-medium">{lookupRef}</span>
                                                <span className="text-[11px] font-semibold text-slate-900">{group.name}</span>
                                                <span className="text-xs text-slate-400">({groupInputs.length} options)</span>
                                            </div>
                                        </td>
                                        {viewHeaders.map((_, colIndex) => (
                                            <td key={colIndex} className="min-w-[55px] h-[24px] bg-lime-50"></td>
                                        ))}
                                    </tr>
                                    {/* Selected values for each subgroup */}
                                    {subgroupedInputs.map((sg, sgIdx) => {
                                        if (sg.inputs.length === 0) return null

                                        const key = sg.id ?? 'root'
                                        const selectedIdx = selectedIndices[key] ?? 0
                                        const selectedInput = sg.inputs[selectedIdx] || sg.inputs[0]

                                        if (!selectedInput) return null

                                        // Use pre-computed monthly array from inputGlassArrays
                                        const inputMonthlyArray = inputGlassArrays[`inputtype3_${selectedInput.id}`] || new Array(timeline.periods).fill(0)
                                        const subgroupRef = `${lookupRef}.${sgIdx + 1}`

                                        return (
                                            <tr key={sg.id ?? 'root'} className="bg-amber-50 border-b border-amber-200">
                                                <td className="frozen-col w-[180px] min-w-[180px] border-r border-amber-200 px-2 py-1 pl-4 bg-amber-50">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-xs text-amber-600 bg-amber-100 px-1 py-0 rounded font-medium">
                                                            {subgroupRef}
                                                        </span>
                                                        {sg.name && (
                                                            <span className="text-xs text-slate-500">{sg.name}:</span>
                                                        )}
                                                        <span className="text-[11px] font-medium text-amber-800">{selectedInput.name}</span>
                                                        <span className="text-[10px] text-amber-500">‚óè selected</span>
                                                    </div>
                                                </td>
                                                {viewHeaders.map((header, colIndex) => {
                                                    // Use inputGlassArrays directly with aggregation for non-monthly views
                                                    const cellValue = isMonthlyView
                                                        ? (inputMonthlyArray[header.index] ?? 0)
                                                        : getAggregatedValueForArray(inputMonthlyArray, header.indices, lookupType)
                                                    return (
                                                        <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0 bg-amber-50">
                                                            <DisplayCell value={cellValue} category="value" isTimeline={false} />
                                                        </td>
                                                    )
                                                })}
                                            </tr>
                                        )
                                    })}
                                </React.Fragment>
                            )
                        })}
                    </>
                )
            })()}
        </>
    )
}

function ModulesSubTab({ modules, viewHeaders, viewMode }) {
    if (!modules || modules.length === 0) {
        return (
            <tr>
                <td colSpan={viewHeaders.length + 1} className="text-center py-12 text-slate-400">
                    No modules added yet
                </td>
            </tr>
        )
    }

    return (
        <>
            {modules.map((module, moduleIdx) => (
                <React.Fragment key={module.id}>
                    {/* Module Header Row */}
                    <tr className="hover:bg-slate-50 transition-colors border-b border-slate-200 bg-slate-50">
                        <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-200 px-2 py-1">
                            <div className="flex items-center gap-2">
                                <span className="text-xs text-orange-600 bg-orange-100 px-1 py-0 rounded font-medium">M{moduleIdx + 1}</span>
                                <span className="text-[11px] font-semibold text-slate-900">{module.name}</span>
                                <span className="text-xs text-slate-400">({module.outputs?.length || 0} outputs)</span>
                            </div>
                        </td>
                        {viewHeaders.map((header, colIndex) => (
                            <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0 bg-slate-50">
                                <DisplayCell value={null} category="value" isTimeline={false} />
                            </td>
                        ))}
                    </tr>
                    {/* Module Output Rows */}
                    {module.outputs && module.outputs.map((output, outputIdx) => {
                        // TODO: Get actual calculated output array when available
                        const outputArray = []
                        return (
                            <tr key={output} className="hover:bg-slate-50 transition-colors border-b border-slate-100">
                                <td className="frozen-col w-[180px] min-w-[180px] border-r border-slate-200 px-2 py-0.5 pl-5">
                                    <div className="flex items-center gap-2">
                                        <span className="text-xs text-orange-500 bg-orange-50 px-1 py-0 rounded">
                                            M{moduleIdx + 1}.{outputIdx + 1}
                                        </span>
                                        <span className="text-[11px] text-slate-700">{output.replace(/_/g, ' ')}</span>
                                    </div>
                                </td>
                                {viewHeaders.map((header, colIndex) => {
                                    const isMonthlyView = viewMode === 'M'
                                    const cellValue = isMonthlyView
                                        ? (outputArray[header.index] ?? 0)
                                        : getAggregatedValueForArray(outputArray, header.indices, 'flow')
                                    return (
                                        <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[22px] p-0">
                                            <DisplayCell value={cellValue} category="module" isTimeline={false} />
                                        </td>
                                    )
                                })}
                            </tr>
                        )
                    })}
                </React.Fragment>
            ))}
        </>
    )
}

function ResultsSubTab({ calculations, calculationsTabs, calculationsGroups, calculationResults, calculationTypes, viewHeaders, viewMode, calcIndexMap }) {
    if (!calculations || calculations.length === 0) {
        return (
            <tr>
                <td colSpan={viewHeaders.length + 1} className="text-center py-12 text-slate-400">
                    No calculations yet
                </td>
            </tr>
        )
    }

    // Helper to render a single calculation row
    const renderCalcRow = (calc, isIndented = false) => {
        const calcRef = `R${calcIndexMap.get(calc.id)}`
        const resultArray = calculationResults[calcRef] || []
        const calcType = calculationTypes?.[calcRef] || 'flow'
        return (
            <tr key={calc.id} className="hover:bg-slate-50 transition-colors border-b border-slate-200">
                <td className={`frozen-col w-[180px] min-w-[180px] border-r border-slate-200 py-2 ${isIndented ? 'px-8' : 'px-4'}`}>
                    <div className="flex items-center gap-2">
                        <span className="text-xs text-rose-600 bg-rose-100 px-1 py-0 rounded font-medium">{calcRef}</span>
                        <span className="text-[11px] font-medium text-slate-900">{calc.name}</span>
                        <span className={`text-[10px] px-1 py-0.5 rounded ${
                            calcType === 'flow'
                                ? 'text-emerald-600 bg-emerald-50'
                                : 'text-slate-500 bg-slate-100'
                        }`}>
                            {calcType === 'flow' ? 'flow' : 'stock'}
                        </span>
                    </div>
                </td>
                {viewHeaders.map((header, colIndex) => {
                    const isMonthlyView = viewMode === 'M'
                    const cellValue = isMonthlyView
                        ? (resultArray[header.index] ?? 0)
                        : getAggregatedValueForArray(resultArray, header.indices, calcType)
                    return (
                        <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0">
                            <DisplayCell value={cellValue} category="result" isTimeline={false} />
                        </td>
                    )
                })}
            </tr>
        )
    }

    // Helper to render a group header row
    const renderGroupHeader = (group, groupCalcs) => {
        // Calculate group subtotal (sum of flows only)
        const groupSubtotalByPeriod = viewHeaders.map((header) => {
            return groupCalcs.reduce((sum, calc) => {
                const calcRef = `R${calcIndexMap.get(calc.id)}`
                const resultArray = calculationResults[calcRef] || []
                const calcType = calculationTypes?.[calcRef] || 'flow'
                if (calcType === 'stock') return sum
                if (viewMode === 'M') {
                    return sum + (resultArray[header.index] ?? 0)
                } else {
                    return sum + getAggregatedValueForArray(resultArray, header.indices || [header.index], calcType)
                }
            }, 0)
        })

        return (
            <tr key={`group-${group.id}`} className="bg-rose-50 border-b border-rose-200">
                <td className="frozen-col w-[180px] min-w-[180px] border-r border-rose-200 px-6 py-2 bg-rose-50">
                    <span className="text-[11px] font-semibold text-rose-800">{group.name}</span>
                </td>
                {viewHeaders.map((header, colIndex) => (
                    <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0 bg-rose-50">
                        <DisplayCell value={groupSubtotalByPeriod[colIndex]} category="result" isTimeline={false} />
                    </td>
                ))}
            </tr>
        )
    }

    // Helper to render a tab header row
    const renderTabHeader = (tab) => {
        return (
            <tr key={`tab-${tab.id}`} className="bg-indigo-100 border-b border-indigo-200">
                <td className="frozen-col w-[180px] min-w-[180px] border-r border-indigo-200 px-2 py-1 bg-indigo-100">
                    <span className="text-[11px] font-bold text-indigo-900">{tab.name}</span>
                </td>
                {viewHeaders.map((_, colIndex) => (
                    <td key={colIndex} className="spreadsheet-cell min-w-[55px] h-[24px] p-0 bg-indigo-100" />
                ))}
            </tr>
        )
    }

    // Get first tab id for backwards compatibility
    const firstTabId = (calculationsTabs || [])[0]?.id

    return (
        <>
            {/* Calculations organized by tabs */}
            {(calculationsTabs || []).map((tab) => {
                const isFirstTab = tab.id === firstTabId
                // Include calculations without tabId in first tab for backwards compatibility
                const tabGroups = (calculationsGroups || []).filter(g =>
                    g.tabId === tab.id || (isFirstTab && !g.tabId)
                )
                const tabCalcs = calculations.filter(c =>
                    c.tabId === tab.id || (isFirstTab && !c.tabId)
                )

                // Skip tabs with no calculations
                if (tabCalcs.length === 0) return null

                return (
                    <React.Fragment key={tab.id}>
                        {/* Tab header */}
                        {renderTabHeader(tab)}

                        {/* Groups within this tab */}
                        {tabGroups.map((group) => {
                            const groupCalcs = tabCalcs.filter(c => c.groupId === group.id)
                            if (groupCalcs.length === 0) return null

                            return (
                                <React.Fragment key={group.id}>
                                    {renderGroupHeader(group, groupCalcs)}
                                    {groupCalcs.map(calc => renderCalcRow(calc, true))}
                                </React.Fragment>
                            )
                        })}

                        {/* Ungrouped calculations in this tab */}
                        {tabCalcs
                            .filter(c => !c.groupId || !tabGroups.some(g => g.id === c.groupId))
                            .map(calc => renderCalcRow(calc, false))
                        }
                    </React.Fragment>
                )
            })}

            {/* Calculations with invalid tabId (orphaned - tab was deleted) */}
            {(() => {
                // Only show calcs that have a tabId that doesn't exist (not just missing tabId)
                const orphanedCalcs = calculations.filter(c =>
                    c.tabId && !(calculationsTabs || []).some(t => t.id === c.tabId)
                )
                if (orphanedCalcs.length === 0) return null

                const orphanedGroups = (calculationsGroups || []).filter(g =>
                    g.tabId && !(calculationsTabs || []).some(t => t.id === g.tabId)
                )

                return (
                    <>
                        {orphanedGroups.map((group) => {
                            const groupCalcs = orphanedCalcs.filter(c => c.groupId === group.id)
                            if (groupCalcs.length === 0) return null

                            return (
                                <React.Fragment key={group.id}>
                                    {renderGroupHeader(group, groupCalcs)}
                                    {groupCalcs.map(calc => renderCalcRow(calc, true))}
                                </React.Fragment>
                            )
                        })}
                        {orphanedCalcs
                            .filter(c => !c.groupId || !orphanedGroups.some(g => g.id === c.groupId))
                            .map(calc => renderCalcRow(calc, false))
                        }
                    </>
                )
            })()}
        </>
    )
}
